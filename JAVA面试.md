# JAVA面试

[toc]

### java基础

#### 1. JDK 和 JRE 有什么区别？

* JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。
* JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。

具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。

#### 2.== 和 equals 的区别是什么？

equals和=最大的区别是一个是方法一个是运算符。

==:如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。

equals（:用来比较方法两个对象的内容是否相等。

注意：equals方法不能用于基本数据类型的变量，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址。

#### 3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？

作者：代码界的小白
链接：https://www.nowcoder.com/discuss/820924?source_id=discuss_experience_nctrack&channel=-1
来源：牛客网



## 重写和重载的区别

回答：

重载是发生在同一个类中，具有相同的方法名，但是有不同的参数，参数的个数不一样、参数的位置不一样，这就叫重载，常见的就比如构造方法，有有参构造和无参构造。

重写是发生在当子类继承父类时，对父类中的一些方法根据自己的需求进行重写操作。

作者：代码界的小白
链接：https://www.nowcoder.com/discuss/820924?source_id=discuss_experience_nctrack&channel=-1
来源：牛客网



## HashMap与ConcurrentHashMap在Jdk1.7和1.8的区别

### HashMap

回答：在jdk1.7之前HashMap是基于数组和[链表]()实现的，而且采用头插法。

而jdk1.8 之后在解决哈希冲突时有了较大的变化，当[链表]()长度大于阈值（默认为 8）（将[链表]()转换成[红黑树]()前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为[红黑树]()）时，将[链表]()转化为[红黑树]()，以减少搜索时间。采用尾插法。

HashMap默认的初始化大小为 16。当HashMap中的**元素个数之和**大于负载因子*当前容量的时候就要进行扩充，容量变为原来的 2 倍。（这里注意不是数组中的个数，而且数组中和链/树中的所有元素个数之和！）

### ConcurrentHashMap

回答：在jdk1.7是 **分段的数组+[链表]()** ，jdk1.8的时候跟HashMap1.8的时候一样都是基于数组+[链表]()/[红黑树]()。

ConcurrentHashMap是线程安全的

（1）在jdk1.7的时候是使用分段所segment，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。

（2）在jdk1.8的时候摒弃了 Segment的概念，而是直接用 Node 数组+[链表]()+[红黑树]()的数据结构来实现，并发控制使用 **synchronized** 和 **CAS** 来操作。synchronized只锁定当前[链表]()或红黑[二叉树]()的首节点。

作者：代码界的小白
链接：https://www.nowcoder.com/discuss/820924?source_id=discuss_experience_nctrack&channel=-1
来源：牛客网



## TCP与UDP区别

回答:TCP 和UDP都是属于运输层的

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

![img](https://uploadfiles.nowcoder.com/compress/mw1000/images/20211213/3639882_1639387402651/71CE0BC5FB4BBBA2BD6B11ED67B35432) 

![img](https://uploadfiles.nowcoder.com/files/20211213/3639882_1639387324200/71b2fb09-4b6e-4394-8297-8f69b23c3fe0.png)

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

![img](https://uploadfiles.nowcoder.com/files/20211213/3639882_1639387324290/96d2f35f-c6a4-47ed-b273-5cdb800b248f.png)

### 追问：TCP和UDP的使用场景？

某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等。

TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

### TCP是如何保证可靠传输的？

1. 应用数据被分割成 TCP 认为最适合发送的数据块。 
2. TCP 给发送的每一个包进行编号，接收方对数据包进行[排序]()，把有序数据传送给应用层。 
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 
4. TCP 的接收端会丢弃重复的数据。 
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。 
7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。



### java面向对象有哪些特征？

面向对象编程是利用类和对象编程的一种思想。万物可归类，类是对于世界事物的高度抽象，不同的事物之间有不同的关系，一个类自身与外界的封装关系，一个父类和子类的继承关系，一个类和多个类的多态关系。万物皆对象，对象是具体的世界事物，面向对象的三大特征封装，继承，多态。封装，封装说明一个类行为和属性与其他类的关系，低耦合，高内聚；继承是父类和子类的关系，多态说的是类与类的关系。
封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。属性的封装：使用者只能通过事先定制好的方法来访问数据，可以方便地加入逻辑控制，限制对属性的不合理操作；方法的封装：使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用；便于修改，增强代码的可维护性；
继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。在本质上是特殊—一般的关系，即常说的is—a关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。继承的类叫做子类（派生类或者超类），被继承的类叫做父类（或者基类），比如从猫类、狗类、虎类中可以抽象出一个动物类，具有和猫、狗、虎类的共同特性（吃、跑、叫等）。Java通过extends关键字来实现继承，父类中通过private定义的变量和方法不会被继承，不能在子类中直接操作父类通过private定义的变量以及方法。继承避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围，在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。
相比于封装和继承，Java多态是三大特性中比较难的一个，封装和继承最后归结于多态，多态指的是类和类的关系，两个类由继承关系，存在有方法的重写，故而可以在调用时有父类引用指向子类对象。多态必备三个要素：继承，重写，父类引用指向子类对象。

### ArrayList和LinkedList的区别？

ArrayList和LinkedList都实现了List接口，他们有以下的不同点：
ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O（n）。
**相对于ArrayList，LinkedList的插入，添加，删除操作速度更快**，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
LinkedList比ArrayList**更占内存**，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。
也可以参考ArrayList vs.LinkedList。
1）因为Array是基于索引（index）的数据结构，它使用索引在数组中**搜索和读取数据是很快**的。Array 获取数据的时间复杂度是O（1），但是要**删除数据却是开销很大**的，因为这需要重排数组中的所有数据。
2）相对于ArrayList，LinkedList **插入是更快**的。因为LinkedList不像ArrayList一样，不需要改变数组的大小， 也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O（n），而LinkedList中插入或删除的时间复杂度仅为0（1）。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。
3）类似于**插入数据，删除数据时，LinkedList也优于ArrayList**。
4）LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置（一个LinkedList实例存储了两个值：Node＜E＞ first和Node＜E＞last分别表示链表的其实节点和尾节点，每个Node实例存储了三个值：E item，Node next，Node pre）。
什么场景下更适宜使用LinkedList，而不用ArrayList
1）你的应用不会随机访问数据。因为如果你需要LinkedList中的第n个元素的时候，你需要从第一个元素顺序数到第n个数据，然后读取数据。
2）你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。

### 高并发中的集合有哪些问题？

**第一代线程安全集合类**
Vector, Hashtable
是怎么保证线程安排的：使用synchronized修饰方法

缺点：效率低下

**第二代线程非安全集合类**

ArrayList, HashMap
线程不安全，但是性能好，用来替代Vector， Hashtable

使用ArrayList， HashMap，需要线程安全怎么办呢？
使用Collections.synchronizedList(list);Collections.synchronizedMap（m);
底层使用synchronized代码块锁虽然也是锁住了所有的代码，但是锁在方法里边，并所在方法外边性能可以理解为稍有提高吧。毕竟进方法本身就要分配资源的
**第三代线程安全集合类**
在大量并发情况下如何提高集合的效率和安全呢？java.util.concurrent.*
ConcurrentHashMap: CopyOnWriteArrayList:
CopyOnWriteArraySet: 注意 不CopyOnWriteHashSet*
底层大都采用Lock锁（1.8的ConcurrentHashMap不使用Lock锁），保证安全的同时，性能也很高。



### jdk1.8的新特性有哪些？



1.接口的默认方法

2.Lambda表达式

3.函数式接口

### java接口和抽象类有哪些区别？

既有概念：植物，动物，用抽象类

共同事物有的共同特征，会飞的，会跑的，用接口

相同：
1．不能够实例化
2．可以将抽象类和接口类型作为引用类型
3．一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要
被声明为抽象类
不同：
抽象类：
1．抽象类中可以定义构造器
2．可以有抽象方法和具体方法
3．接口中的成员全都是public的
4．抽象类中可以定义成员变量
5．有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法
6．抽象类中可以包含静态方法
7．一个类只能继承一个抽象类

接口：
1．接口中不能定义构造器
2．方法全部都是抽象方法
3．抽象类中的成员可以是private、默认、protected、public
4．接口中定义的成员变量实际上都是常量
5．接口中不能有静态方法
6．一个类可以实现多个接口

### hashcode和equals如何使用？

前七后八

equals（）源自于java.lang.Object，该方法用来简单验证两个对象的相等性。Object类中定义的默认实现只检查两个对象的对象引用，以验证它们的相等性。通过重写该方法，可以自定义验证对象相等新的规则，如果你使用ORM处理一些对象的话，你要确保在hashCodeo和equals(）对象中使用getter和setteri而不是直接引用成员变量

hashCode（）源自于java.lang.Object，该方法用于获取给定对象的唯一的整数（散列码）。当这个对象需要存储在哈希表这样的数据结构时，这个整数用于确定桶的位置。默认情况下，对象的hashCode（）方法返回对象所在内存地址的整数表示。hashCode（）是HashTable、HashMap和HashSet使用的。默认的，Object类的hashCodeo方法返回这个对象存储的内存地址的编号。

hash散列算法，使得在hash表中查找一个记录速度变O（）.每个记录都有自己的hashcode，散列算法按照nashcode把记录放置在合适的位置.在查找一个记录，首先先通过hashcode快速定位记录的位置.然后再通过equals来比较是否相等。如果hashcodei没找到，则不equal，元素不存在于哈希表中；即使找到了，也只需执行hashcode相同的几个元素的equal，如果不equal，还是不存在哈希表中。

![image-20220301083258729](C:\Users\Xlibi\AppData\Roaming\Typora\typora-user-images\image-20220301083258729.png)

### java代理的几种实现方式

第一种：静态代理只能静态的代理某些类或者某些方法，不推荐使用功能比较弱，但是编码简单

第二种：动态代理，包含Proxyt代理和CGLIB动态代理

Proxy代理是JDK内置的动态代理

特点：面向接口的，不需要导入三方依赖的动态代理，可以对多个不同的接口进行增强通过反射读取注解时，只能读取到接口上的注解原理：面向接口，只能对实现类在实现接口中定义的方法进行增强

### java的异常处理方式

抛出异常：throw：异常对象，方法内部

捕获异常：try ，catch，finally(IO流关闭，网络流关闭，无论是否异常都执行)

声明异常：throws：声明，可能出现异常

Java通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在中，每个异常都是一个对象，它是hrowable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally.在av应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。

throwi和throws的区别：

（1）位置不同：

throw:方法内部

throws:方法的签名处，方法的声明处

（2）内容不同：

throw+异常对象（检查异常，运行时异常）

throws+异常的类型（可以多个类型，用，拼接）

（3）作用不同：

throw:异常出现的源头，制造异常。

throws:在方法的声明处，告诉方法的调用者，这个方法中可能会出现我声明的这些异常。然后调用者对这个异常进行处理：要么自己处理要么再继续向外抛出异常

### java重写跟重载有哪些区别

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。

方法重载的规则：

1.方法名一致，参数列表中参数的顺序，类型，个数不同。

2.重载与方法的返回值无关，存在于父类和子类，同类中。

3.可以抛出不同的异常，可以有不同修饰符



方法重写的规则：

.参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。

.构造方法不能被写，声明为final的方法不能被直写，声明为static的方法不能被写，但是能够被再次声明。

3.访问权限不能比父类中被重写的方法的访问权限更低。

.重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。

![image-20220301104234345](C:\Users\Xlibi\AppData\Roaming\Typora\typora-user-images\image-20220301104234345.png)

### Sting，StringBuffer，StringBuilder区别及使用

![image-20220301104733873](C:\Users\Xlibi\AppData\Roaming\Typora\typora-user-images\image-20220301104733873.png)

session依赖于cookie。

当客户端首次访问服务器时，服务器会为其创建一个session对象，该对象具有一个唯一标识SESSIONID。并且在响应阶段，服务器会创建一个cookie，并将SESSIONID存入其中。

客户端通过响应的cookie而持有SESSIONID，所以当它再次访问服务器时，会通过cookie携带这个SESSIONID。服务器获取到SESSIONID后，就可以找到与之对应的session对象，进而从这个session中获取该客户端的状态。

### 什么是Session?

服务器为了保存用户状态而创建的一个特殊的对象。

### bean生命周期

![image-20220705090022244](C:\Users\Xlibi\AppData\Roaming\Typora\typora-user-images\image-20220705090022244.png)
