## linux

[toc]

**Linux系统中的一切都是文件**

### 环境安装

#### vmware
### 安装软件
RPM （红帽软件包管理器）

##### 常用的RPM软件包命令

rpm -ivh filename.rpm| 安装软件
:--------|----------
 rpm -e filename.rpm | 卸载软件
 rpm -qpi filename.rpm| 查询软件描述信息
 rpm -qpl filename.rpm |列出软件文件信息
 rpm -qf filename|查询文件属于哪个RPM
##### Yum软件仓库

Yum软件仓库便是为了进一步降低软件安装难度和复杂度而设计的技术。Yum软件仓库可以根据用户的要求分析出所需软件包及其相关的依赖关系，然后自动从服务器下载软件包并安装到系统。

##### 存在问题

分析不准确、内存占用量大、不能多人同时安装软件等硬伤

##### 更好的解决方式-DNF

DNF特别友好地继承了原有的命令格式，且使用习惯上也保持了一致。大家不用担心不会操作，我们来看一个例子。以前，安装软件用的命令是“yum install软件包名称”，那么现在则是“dnf install软件包名称”（也就是说，将yum替换成dnf即可）。

### 系统初始化进程

Linux系统的开机过程是这样的，即先从BIOS开始，然后进入Boot Loader，再加载系统内核，然后内核进行初始化，最后启动初始化进程。初始化进程作为Linux系统启动后的第一个正式服务，它需要完成Linux系统中相关的初始化工作，为用户提供合适的工作环境。同学们可以将初始化进程粗犷地理解成从我们按下开机键到看见系统桌面的这个过程。初始化进程完成了一大半工作。
红帽RHEL 7/8系统替换掉了熟悉的初始化进程服务System V init，正式采用全新的systemd初始化进程服务。

表1-4                  服务的启动、重启、停止、重载、查看状态等常用命令

| 老系统命令          | 新系统命令              | 作用                           |
| ------------------- | ----------------------- | ------------------------------ |
| service foo start   | systemctl start httpd   | 启动服务                       |
| service foo restart | systemctl restart httpd | 重启服务                       |
| service foo stop    | systemctl stop httpd    | 停止服务                       |
| service foo reload  | systemctl reload httpd  | 重新加载配置文件（不终止服务） |
| service foo status  | systemctl status httpd  | 查看服务状态                   |

表1-5                  服务开机启动、不启动、查看各级别下服务启动状态等常用命令

| 老系统命令        | 新系统命令                             | 作用                               |
| ----------------- | -------------------------------------- | ---------------------------------- |
| chkconfig foo on  | systemctl enable httpd                 | 开机自动启动                       |
| chkconfig foo off | systemctl disable httpd                | 开机不自动启动                     |
| chkconfig foo     | systemctl is-enabled httpd             | 查看特定服务是否为开机自启动       |
| chkconfig --list  | systemctl list-unit-files --type=httpd | 查看各个级别下服务的启动与禁用情况 |



### shell命令

Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。
人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg)

Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器。

4项优势：

~~~text
通过上下方向键来调取执行过的Linux命令；

命令或参数仅需输入前几位就可以用Tab键补全；

具有强大的批处理[脚本](https://www.linuxcool.com/)；

具有实用的环境变量功能。
~~~

#### 常见的执行Linux命令的格式

~~~text
命令名称     [命令参数]     [命令对象]
~~~

**命令名称**：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。

**命令参数**：用于对命令进行调整，参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“--”与“-”作为前缀。

**命令对象**：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。

*注意：命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。*

man命令自身的帮助信息----manman

表2-2                      man命令中常用按键以及作用

| 按键      | 作用                               |
| --------- | ---------------------------------- |
| 空格键    | 向下翻一页                         |
| PaGe down | 向下翻一页                         |
| PaGe up   | 向上翻一页                         |
| home      | 直接前往首页                       |
| end       | 直接前往尾页                       |
| /         | 从上至下搜索某个关键词，如“/linux” |
| ?         | 从下至上搜索某个关键词，如“?linux” |
| n         | 定位到下一个搜索到的关键词         |
| N         | 定位到上一个搜索到的关键词         |
| q         | 退出帮助文档                       |

表2-3                     man命令中帮助信息的结构以及意义

| 结构名称    | 代表意义                 |
| ----------- | ------------------------ |
| NAME        | 命令的名称               |
| SYNOPSIS    | 参数的大致使用方法       |
| DESCRIPTION | 介绍说明                 |
| EXAMPLES    | 演示（附带简单说明）     |
| OVERVIEW    | 概述                     |
| DEFAULTS    | 默认的功能               |
| OPTIONS     | 具体的可用选项（带介绍） |
| ENVIRONMENT | 环境变量                 |
| FILES       | 用到的文件               |
| SEE ALSO    | 相关的资料               |
| HISTORY     | 维护历史与联系方式       |

[root@linuxprobe～]#这部分内容是**终端提示符**

展示一些基本的信息—当前登录用户名为root，简要的主机名是linuxprobe，所在目录是～

\#表示管理员身份（如果是$则表示普通用户，相应的权限也会小一些）。

**Tab键：实现对命令、参数或文件的内容补全。**

**Ctrl+c组合键**：当同时按下键盘上的Ctrl和字母c的时候，意味着终止当前进程的运行。

**Ctrl+d组合键**：当同时按下键盘上的Ctrl和字母d的时候，表示键盘输入结束。

**Ctrl+l组合键**：当同时按下键盘上的Ctrl和字母l的时候，会清空当前终端中已有的内容（相当于清屏操作）。

#### 常用系统工作命令

##### echo命令

语法格式为“echo [字符串] [$变量]”，在终端设备上输出字符串或变量提取后的值。

例如，把指定字符串“LinuxProbe.com”输出到终端屏幕的命令为：

```
[root@linuxprobe ~]# echo LinuxProbe.com
```

该命令会在终端屏幕上显示如下信息：

```
LinuxProbe.com
```

下面使用“$变量”的方式提取出变量SHELL的值，并将其输出到屏幕上：

```
[root@linuxprobe ~]# echo $SHELL
/bin/bash
```

##### date命令

显示或设置系统的时间与日期，语法格式为“date [+指定的格式]”。

表2-4                        date命令中的参数及其作用

| 参数 | 作用                             |
| ---- | -------------------------------- |
| %S   | 秒（00～59）                     |
| %M   | 分钟（00～59）                   |
| %H   | 小时（00～23）                   |
| %I   | 小时（00～12）                   |
| %m   | 月份（1~12）                     |
| %p   | 显示出AM或PM                     |
| %a   | 缩写的工作日名称（例如：Sun）    |
| %A   | 完整的工作日名称（例如：Sunday） |
| %b   | 缩写的月份名称（例如：Jan）      |
| %B   | 完整的月份名称（例如：January）  |
| %q   | 季度（1~4）                      |
| %y   | 简写年份（例如：20）             |
| %Y   | 完整年份（例如：2020）           |
| %d   | 本月中的第几天                   |
| %j   | 今年中的第几天                   |
| %n   | 换行符（相当于按下回车键）       |
| %t   | 跳格（相当于按下Tab键）          |

按照默认格式查看当前系统时间的date命令如下所示：

```
[root@linuxprobe ~]# date
Sat Sep 5 09:13:45 CST 2020
```

按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的date命令如下所示：

```
[root@linuxprobe ~]# date "+%Y-%m-%d %H:%M:%S"
2020-09-05 09:14:35
```

将系统的当前时间设置为2020年11月1日8点30分的date命令如下所示：

```
[root@linuxprobe ~]# date -s "20201101 8:30:00"
Sun Nov 1 08:30:00 CST 2020
```

##### timedatectl命令

设置系统的时间，英文全称为“time date control”，语法格式为“timedatectl [参数]”。

表2-5                        timedatectl命令中的参数以及作用

| 参数           | 作用         |
| -------------- | ------------ |
| status         | 显示状态信息 |
| list-timezones | 列出已知时区 |
| set-time       | 设置系统时间 |
| set-timezone   | 设置生效时区 |

如果您查到的时区不是上海（Asia/Shanghai），可以手动进行设置：

```
[root@linuxprobe ~]# timedatectl set-timezone Asia/Shanghai
```

如果时间还是不正确，可再手动修改系统日期：

```
[root@linuxprobe ~]# timedatectl set-time 2021-05-18
```

而如果想修改时间的话，也很简单：

```
[root@linuxprobe ~]# timedatectl set-time 9:30
[root@linuxprobe ~]# date 
Tue May 18 09:30:01 CST 2021
```

##### rebot命令

重启系统，输入该命令后按回车键执行即可。

管理员用户操作，普通用户在执行该命令时可能会被拒绝。

##### poweroff命令

关闭系统，输入该命令后按回车键执行。管理员用户操作，普通用户在执行该命令时可能会被拒绝。

##### wget命令

终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。

表2-6                        wget命令中的参数以及作用

| 参数 | 作用                                 |
| ---- | ------------------------------------ |
| -b   | 后台下载模式                         |
| -P   | 下载到指定目录                       |
| -t   | 最大尝试次数                         |
| -c   | 断点续传                             |
| -p   | 下载页面内所有资源，包括图片、视频等 |
| -r   | 递归下载                             |

##### ps命令

查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。

ps命令与管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。ps命令的常见参数以及作用如表2-7所示。

表2-7                         ps命令中的参数以及作用

| 参数 | 作用                               |
| ---- | ---------------------------------- |
| -a   | 显示所有进程（包括其他用户的进程） |
| -u   | 用户以及其他详细信息               |
| -x   | 显示没有控制终端的进程             |

Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。

~~~text
R（运行）：进程正在运行或在运行队列中等待。
S（中断）：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该   状态。
D（不可中断）：进程不响应系统异步信号，即便用kill命令也不能将其中断。
Z（僵死）：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。
T（停止）：进程收到停止信号后停止运行。
~~~

除了上面5种常见的进程状态，还有可能是高优先级（<）、低优先级（N）、被锁进内存（L）、包含子进程（s）以及多线程（l）这5种补充形式。

当执行ps aux命令后通常会看到如表2-8所示的进程状态。表2-8只是列举了部分输出值，而且正常的输出值中不包括中文注释。

当执行ps aux命令后通常会看到如表2-8所示的进程状态。表2-8只是列举了部分输出值，而且正常的输出值中不包括中文注释。

表2-8                              进程状态

| USER         | PID      | %CPU         | %MEM       | VSZ                      | RSS                        | TTY      | STAT     | START        | TIME              | COMMAND                                                      |
| ------------ | -------- | ------------ | ---------- | ------------------------ | -------------------------- | -------- | -------- | ------------ | ----------------- | ------------------------------------------------------------ |
| 进程的所有者 | 进程ID号 | 运算器占用率 | 内存占用率 | 虚拟内存使用量(单位是KB) | 占用的固定内存量(单位是KB) | 所在终端 | 进程状态 | 被启动的时间 | 实际使用CPU的时间 | 命令名称与参数                                               |
| root         | 1        | 0.0          | 0.5        | 244740                   | 10636                      | ?        | Ss       | 07:54        | 0:02              | /usr/lib/systemd/ systemd --switched-root --system --deserialize 18 |
| root         | 2        | 0.0          | 0.0        | 0                        | 0                          | ?        | S        | 07:54        | 0:00              | [kthreadd]                                                   |
| root         | 3        | 0.0          | 0.0        | 0                        | 0                          | ?        | I<       | 07:54        | 0:00              | [rcu_gp]                                                     |
| root         | 4        | 0.0          | 0.0        | 0                        | 0                          | ?        | I<       | 07:54        | 0:00              | [rcu_par_gp]                                                 |

*在Linux系统中的命令参数有长短格式之分，长格式和长格式之间不能合并，长格式和短格式之间也不能合并，但短格式和短格式之间是可以合并的，合并后仅保留一个减号（-）即可。另外ps命令可允许参数不加减号（-），因此可直接写成ps aux的样子。*

##### pstree命令

以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。

##### top命令

动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。动态地查看系统状态。

##### nice命令

调整进程的优先级，语法格式为“nice优先级数字 服务名称”。

在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。例如将bash服务的优先级调整到最高：

```
[root@linuxprobe ~]# nice -n -20 bash
[root@linuxprobe ~]#
```

##### pidof命令

查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。

每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。例如，执行如下命令来查询本机上sshd服务程序的PID：

```
[root@linuxprobe ~]# pidof sshd
2156
```

##### kill命令

终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。

但有时系统会提示进程无法被终止，此时可以加参数-9，表示最高级别地强制杀死进程：

```
[root@linuxprobe ~]# kill -9 2156
```

##### killall命令

终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。

如果在系统终端中执行一个命令后想立即停止它，可以同时按下Ctrl + C组合键（生产环境中比较常用的一个组合键），这样将立即终止该命令的进程。或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾添加一个&符号，这样命令将进入系统后台来执行。

#### 系统状态检测命令

##### ifconfig命令

获取网卡配置与网络状态等信息，英文全称为“interface config”，语法格式为“ifconfig [参数] [网络设备]”。

##### uname命令

查看系统内核版本与系统架构等信息，英文全称为“unix name”，语法格式为“uname [-a]”。

在使用uname命令时，一般要固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、压制时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息

##### uptime命令

查看系统的负载信息，输入该命令后按回车键执行即可。

uptime命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分），负载值越低越好：

```
[root@linuxprobe ~]# uptime
22:49:55 up 10 min, 1 users, load average: 0.01, 0.19, 0.18
```

##### free命令

显示当前系统中内存的使用量信息，语法格式为“free [-h]”。

使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息

```
[root@linuxprobe ~]# free -h
```

表2-9                      执行free -h命令后的输出信息

|       | 内存总量 | 已用量 | 空闲量 | 进程共享的内存量 | 磁盘缓存的内存量 | 缓存的内存量 | 可用量    |
| ----- | -------- | ------ | ------ | ---------------- | ---------------- | ------------ | --------- |
|       | total    | used   | free   | shared           | buffers          | buff/cache   | available |
| Mem:  | 1.9Gi    | 1.4Gi  | 99Mi   | 20Mi             | 450Mi            | 348Mi        |           |
| Swap: | 2.0Gi    | 80Mi   | 1.9Gi  |                  |                  |              |           |



如果不使用-h（易读模式）查看内存使用量情况，则默认以KB为单位。这样一来，服务器如果有几百GB的内存，则换算下来就会是一大长串的数字，真不利于阅读。

##### who命令

查看当前登入主机的用户终端信息，输入该命令后按回车键执行即可。

这3个简单的字母可以快速显示出所有正在登录本机的用户名称以及他们正在开启的终端信息；如果有远程用户，还会显示出来访者的IP地址。表2-10所示为执行who命令后的结果。

```
[root@linuxprobe ~]# who
```

表2-10                     执行who命令的结果

| 登陆的用户名 | 终端设备 | 登陆到系统的时间        |
| ------------ | -------- | ----------------------- |
| root         | tty2     | 2020-07-24 06:26 (tty2) |

##### last命令

调取主机的被访记录，输入该命令后按回车键执行即可。

##### ping命令

测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。

表2-11                         ping命令中的参数以及作用

| 参数 | 作用               |
| ---- | ------------------ |
| -c   | 总共发送次数       |
| -l   | 指定网卡名称       |
| -i   | 每次间隔时间（秒） |
| -W   | 最长等待时间（秒） |

##### tracepath命令

显示数据包到达目的主机时途中经过的所有路由信息，语法格式为“tracepath [参数] 域名”。

当两台主机之间无法正常ping通时，要考虑两台主机之间是否有错误的路由信息，导致数据被某一台设备错误地丢弃。这时便可以使用tracepath命令追踪数据包到达目的主机时途中的所有路由信息，以分析是哪台设备出了问题。

##### netstat命令

netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。

表2-12                         netstat命令中的参数以及作用

| -a   | 显示所有连接中的Socket   |
| ---- | ------------------------ |
| -p   | 显示正在使用的Socket信息 |
| -t   | 显示TCP协议的连接状态    |
| -u   | 显示UDP协议的连接状态    |
| -n   | 使用IP地址，不使用域名   |
| -l   | 仅列出正在监听的服务状态 |
| -i   | 显示网卡列表信息         |
| -r   | 显示路由表信息           |

##### history命令

显示执行过的命令历史，语法格式为“history [-c]”。使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。

##### sosreport命令

收集系统配置及架构信息并输出诊断文档，输入该命令后按回车键执行即可。

#### 查找文件定位命令

##### pwd命令

显示用户当前所处的工作目录，英文全称为“print working directory”，输入该命令后按回车键执行即可。

##### cd命令

切换当前的工作路径，英文全称为“change directory”，语法格式为“cd [参数] [目录]”。“cd -”命令返回到上一次所处的目录，使用“cd..”命令进入上级目录，以及使用“cd～”命令切换到当前用户的家目录，抑或使用“cd～username”命令切换到其他用户的家目录

##### ls命令

显示目录中的文件信息，英文全称为“list”，语法格式为“ls [参数] [文件名称]”。

ls命令的-a参数可以看到全部文件（包括隐藏文件），使用-l参数可以查看文件的属性、大小等详细信息。将这两个参数整合之后，再执行ls命令即可查看当前目录中的所有文件并输出这些文件的属性信息

要查看目录属性信息，则需要额外添加一个-d参数

##### tree命令

以树状图的形式列出目录内容及结构，输入该命令后按回车键执行即可。

##### find命令

按照指定条件来查找文件所对应的位置，语法格式为“find [查找范围] 寻找条件”。

表2-13                       find命令中的参数以及作用

| 参数              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| -name             | 匹配名称                                                     |
| -perm             | 匹配权限（mode为完全匹配，-mode为包含即可）                  |
| -user             | 匹配所有者                                                   |
| -group            | 匹配所有组                                                   |
| -mtime -n +n      | 匹配修改内容的时间（-n指n天以内，+n指n天以前）               |
| -atime -n +n      | 匹配访问文件的时间（-n指n天以内，+n指n天以前）               |
| -ctime -n +n      | 匹配修改文件权限的时间（-n指n天以内，+n指n天以前）           |
| -nouser           | 匹配无所有者的文件                                           |
| -nogroup          | 匹配无所有组的文件                                           |
| -newer f1 !f2     | 匹配比文件f1新但比f2旧的文件                                 |
| -type b/d/c/p/l/f | 匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件） |
| -size             | 匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件） |
| -prune            | 忽略某个目录                                                 |
| -exec …… {}\;     | 后面可跟用于进一步处理搜索结果的命令（下文会有演示）         |

如果要想获取etc目录中所有以host开头的文件列表

```
find /etc -name "host*" -print
```

在整个文件系统中找出所有归属于linuxprobe用户的文件并复制到/root/findresults目录中。
该实验的重点是“-exec {} \;”参数，其中的{}表示find命令搜索出的每一个文件，并且命令的结尾必须是“\;”。完成该实验的具体命令如下：

[root@linuxprobe ~]# find / -user linuxprobe -exec cp -a {} /root/findresults/ \;

##### locate命令

按照名称快速搜索文件所对应的位置，语法格式为“locate文件名称”。

find命令进行全盘搜索虽然更准确，但是效率有点低。如果仅仅是想找一些常见的且又知道大概名称的文件，不如试试locate命令，在使用locate命令时，先使用updatedb命令生成一个索引库文件，这个库文件的名字是/var/lib/mlocate/mlocate.db，后续在使用locate命令搜索文件时就是在该库中进行查找操作，速度会快很多。

第一次使用locate命令之前，记得先执行updatedb命令来生成索引数据库，然后再进行查找：

使用locate命令搜索出所有包含“whereis”名称的文件所在的位置：

##### whereis命令

按照名称快速搜索二进制程序（命令）、源代码以及帮助文件所对应的位置，语法格式为“whereis命令名称”。

简单来说，whereis命令也是基于updatedb命令所生成的索引库文件进行搜索，它与locate命令的区别是不关心那些相同名称的文件，仅仅是快速找到对应的命令文件及其帮助文件所在的位置。

##### which命令

按照指定名称快速搜索二进制程序（命令）所对应的位置，语法格式为“which命令名称”。

hich命令是在PATH变量所指定的路径中，按照指定条件搜索命令所在的路径。也就是说，如果我们既不关心同名文件（find与locate），也不关心命令所对应的源代码和帮助文件（whereis），仅仅是想找到命令本身所在的路径，那么这个which命令就太合适了。

#### 文本文件编辑命令

##### cat命令

用于查看纯文本文件（内容较少的），英文全称为“concatenate”，语法格式为“cat [参数] 文件名称”。

查看文本内容时还想顺便显示行号的话，不妨在cat命令后面追加一个-n参数

##### more命令

查看纯文本文件（内容较多的），语法格式为“more [参数] 文件名称”。使用空格键或回车键向下翻页

##### head命令

查看纯文本文件的前*N*行，语法格式为“head [参数] 文件名称”。

查看前十行

```
head -n 10 ks.cfg
```

##### tail命令

查看纯文本文件的后*N*行或持续刷新文件的最新内容，语法格式为“tail [参数] 文件名称”。

比如需要查看文本内容的最后10行，tail命令的操作方法与head命令非常相似，只需要执行“tail -n 20文件名称”

持续刷新一个文件的内容，命令格式为“tail -f文件名称”

##### tr命令

替换文本内容中的字符，英文全称为“transform”，语法格式为“tr [原始字符] [目标字符]”。

快速地替换文本中的一些词汇,先使用cat命令读取待处理的文本，然后通过管道符把这些文本内容传递给tr命令进行替换操作即可

##### wc命令

统计指定文本文件的行数、字数或字节数，英文全称为“word counts”，语法格式为“wc [参数] 文件名称”。

表2-14                          wc命令中的参数以及作用

| 参数 | 作用         |
| ---- | ------------ |
| -l   | 只显示行数   |
| -w   | 只显示单词数 |
| -c   | 只显示字节数 |

##### stat命令

查看文件的具体存储细节和时间等信息，英文全称为“status”，语法格式为“stat文件名称”。

Linux系统中的文件包含3种时间状态，分别是Access Time（内容最后一次被访问的时间，简称为Atime），Modify Time（内容最后一次被修改的时间，简称为Mtime）以及Change Time（文件属性最后一次被修改的时间，简称为Ctime）。

##### grep命令

按行提取文本内容，语法格式为“grep [参数] 文件名称”。

~~~text
-n参数用来显示搜索到的信息的行号；

-v参数用于反选信息（即没有包含关键词的所有信息行）。
~~~

表2-15                       grep命令中的参数及其作用

| 参数 | 作用                                           |
| ---- | ---------------------------------------------- |
| -b   | 将可执行文件(binary)当作文本文件（text）来搜索 |
| -c   | 仅显示找到的行数                               |
| -i   | 忽略大小写                                     |
| -n   | 显示行号                                       |
| -v   | 反向选择——仅列出没有“关键词”的行。             |

##### cut命令

按“列”提取文本内容，语法格式为“cut [参数] 文件名称”。

使用-d参数来设置间隔符号。-f参数设置需要查看的列数，

```
cut -d : -f 1 /etc/passwd
```

##### diff命令

比较多个文件之间内容的差异，英文全称为“different”，语法格式为“diff [参数] 文件名称A 文件名称B”。

使用--brief参数来确认两个文件是否相同，还可以使用-c参数来详细比较出多个文件的差异之处

##### uniq命令

去除文本中连续的重复行，英文全称为“unique”，语法格式为“uniq [参数] 文件名称”。

##### sort命令

对文本内容进行再排序，语法格式为“sort [参数] 文件名称”。

表2-16                       sort命令中的参数及其作用

| 参数 | 作用           |
| ---- | -------------- |
| -f   | 忽略大小写     |
| -b   | 忽略缩进与空格 |
| -n   | 以数值型排序   |
| -r   | 反向排序       |
| -u   | 去除重复行     |
| -t   | 指定间隔符     |
| -k   | 设置字段范围   |

#### 文件目录管理命令

##### touch命令

创建空白文件或设置文件的时间，语法格式为“touch [参数] 文件名称”。

表2-17                       touch命令中的参数及其作用

| 参数 | 作用                      |
| ---- | ------------------------- |
| -a   | 仅修改“读取时间”（atime） |
| -m   | 仅修改“修改时间”（mtime） |
| -d   | 同时修改atime与mtime      |

```
touch -d "2020-05-04 15:44" anaconda-ks.cfg 
```

##### mkdir命令

创建空白的目录，英文全称为“make directory”，语法格式为“mkdir [参数] 目录名称”。

-p参数来递归创建出具有嵌套层叠关系的文件目录

```
mkdir -p a/b/c/d/e
```

##### cp命令

复制文件或目录，英文全称为“copy”，语法格式为“cp [参数] 源文件名称 目标文件名称”。

~~~
如果目标文件是目录，则会把源文件复制到该目录中；

如果目标文件也是普通文件，则会询问是否要覆盖它；

如果目标文件不存在，则执行正常的复制操作。
~~~

复制命令基本不会出错，唯一需要记住的就是在复制目录时要加上-r参数。cp命令的参数及其作用如表2-18所示。

表2-18                        cp命令中的参数及其作用

| 参数 | 作用                                         |
| ---- | -------------------------------------------- |
| -p   | 保留原始文件的属性                           |
| -d   | 若对象为“链接文件”，则保留该“链接文件”的属性 |
| -r   | 递归持续复制（用于目录）                     |
| -i   | 若目标文件存在则询问是否覆盖                 |
| -a   | 相当于-pdr（p、d、r为上述参数）              |

##### mv命令

剪切或重命名文件，英文全称为“move”，语法格式为“mv [参数] 源文件名称 目标文件名称”。

##### rm命令

删除文件或目录，英文全称为“remove”，语法格式为“rm [参数] 文件  名称”。

系统会默认向您询问是否要执行删除操作，如果不想总是看到这种反复的确认信息，可在rm命令后跟上-f参数来强制删除。另外，要想删除一个目录，需要在rm命令后面加一个-r参数才可以，否则删除不掉。rm命令的参数及其作用如表2-19所示。

表2-19                        rm命令中的参数及其作用

| 参数 | 作用       |
| ---- | ---------- |
| -f   | 强制执行   |
| -i   | 删除前询问 |
| -r   | 删除目录   |
| -v   | 显示过程   |

##### dd命令

按照指定大小和个数的数据块来复制文件或转换文件，语法格式为“dd if=参数值of=参数值count=参数值bs=参数值”。

它能够让用户按照指定大小和个数的数据块来复制文件的内容。还可以在复制过程中转换其中的数据。Linux系统中有一个名为/dev/zero的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此常常使用它作为dd命令的输入文件，来生成一个指定大小的文件。dd命令的参数及其作用如表2-20所示。

表2-20                        dd命令中的参数及其作用

| 参数  | 作用                 |
| ----- | -------------------- |
| if    | 输入的文件名称       |
| of    | 输出的文件名称       |
| bs    | 设置每个“块”的大小   |
| count | 设置要复制“块”的个数 |

用dd命令从/dev/zero设备文件中取出一个大小为560MB的数据块，然后保存成名为560_file的文件

```
dd if=/dev/zero of=560_file count=1 bs=560M
```

##### file命令

查看文件的类型，语法格式为“file文件名称”。

##### tar命令

对文件进行打包压缩或解压，语法格式为“tar参数 文件名称”。

表2-21                        tar命令中的参数及其作用

| 参数 | 作用                   |
| ---- | ---------------------- |
| -c   | 创建压缩文件           |
| -x   | 解开压缩文件           |
| -t   | 查看压缩包内有哪些文件 |
| -z   | 用Gzip压缩或解压       |
| -j   | 用bzip2压缩或解压      |
| -v   | 显示压缩或解压的过程   |
| -f   | 目标文件名             |
| -p   | 保留原始的权限与属性   |
| -P   | 使用绝对路径来压缩     |
| -C   | 指定解压到的目录       |

一般使用“tar -czvf压缩包名称.tar.gz要打包的目录”命令把指定的文件进行打包压缩；相应的解压命令为“tar -xzvf压缩包名称.tar.gz”。

### 重定向

#### 输入输出重定向

输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。

使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。

~~~text、
标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入。

标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕。

错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕。
~~~

对于输入重定向来讲，用到的符号及其作用如表3-1所示。

表3-1                     输入重定向中用到的符号及其作用

| 符号                 | 作用                                         |
| -------------------- | -------------------------------------------- |
| 命令 < 文件          | 将文件作为命令的标准输入                     |
| 命令 << 分界符       | 从标准输入中读入，直到遇见分界符才停止       |
| 命令 < 文件1 > 文件2 | 将文件1作为命令的标准输入并将标准输出到文件2 |



对于输出重定向来讲，用到的符号及其作用如表3-2所示。

表3-2                     输出重定向中用到的符号及其作用

| 符号                               | 作用                                                 |
| ---------------------------------- | ---------------------------------------------------- |
| 命令 > 文件                        | 将标准输出重定向到一个文件中（清空原有文件的数据）   |
| 命令 2> 文件                       | 将错误输出重定向到一个文件中（清空原有文件的数据）   |
| 命令 >> 文件                       | 将标准输出重定向到一个文件中（追加到原有内容的后面） |
| 命令 2>> 文件                      | 将错误输出重定向到一个文件中（追加到原有内容的后面） |
| 命令 >> 文件 2>&1 或 命令 &>> 文件 | 将标准输出与错误输出共同写                           |

命令的报错信息写入到文件使用错误输出重定向。

使用输入重定向把readme.txt文件导入给wc -l命令，统计一下文件中的内容行数：

```
[root@linuxprobe ~]# wc -l < readme.txt
2
```

### 管道命令符

同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。

“**把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入**”

我们完全可以这样使用：“命令A | 命令B | 命令C”

### 命令行的通配符

通配符就是通用的匹配信息的符号，

星号（*）代表匹配零个或多个字符，问号（?）代表匹配单个字符，中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符，而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符。Linux系统中的通配符及含义如表3-3所示。

表3-3                    Linux系统中的通配符及含义

| 通配符      | 含义           |
| ----------- | -------------- |
| *           | 任意字符       |
| ?           | 单个任意字符   |
| [a-z]       | 单个小写字母   |
| [A-Z]       | 单个大写字母   |
| [a-Z]       | 单个字母       |
| [0-9]       | 单个数字       |
| [[:alpha:]] | 任意字母       |
| [[:upper:]] | 任意大写字母   |
| [[:lower:]] | 任意小写字母   |
| [[:digit:]] | 所有数字       |
| [[:alnum:]] | 任意字母加数字 |
| [[:punct:]] | 标点符号       |

### 常用的转义字符

~~~text
反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符。

单引号（' '）：转义其中所有的变量为单纯的字符串。

双引号（" "）：保留其中的变量属性，不进行转义处理。

反引号（` `）：把其中的命令执行后返回结果。
~~~

如果参数中出现了空格，就加双引号；如果参数中没有空格，那就不用加双引号。

### 重要的环境变量

在Linux系统中，变量名称一般都是大写的，命令则都是小写的，这是一种约定俗成的规范。

命令在Linux中的执行分为4个步骤。

**第1步**：判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是绝对路径则直接执行，否则进入第2步继续判断。

**第2步**：Linux系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令名称来替换原本的命令名称。

**第3步**：Bash解释器判断用户输入的是内部命令还是外部命令。内部命令是解释器内部的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤4继续处理。可以使用“type命令名称”来判断用户输入的命令是内部命令还是外部命令

**第4步**：系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作PATH，可以简单地把它理解成是“解释器的小助手”，作用是告诉Bash解释器待执行的命令可能存放的位置，然后Bash解释器就会乖乖地在这些位置中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用冒号间隔，对这些路径的增加和删除操作将影响到Bash解释器对Linux命令的查找。

使用env命令来查看Linux系统中所有的环境变量

表3-4                    Linux系统中最重要的10个环境变量

| 变量名称     | 作用                             |
| ------------ | -------------------------------- |
| HOME         | 用户的主目录（即家目录）         |
| SHELL        | 用户在使用的Shell解释器名称      |
| HISTSIZE     | 输出的历史命令记录条数           |
| HISTFILESIZE | 保存的历史命令记录条数           |
| MAIL         | 邮件保存路径                     |
| LANG         | 系统语言、语系名称               |
| RANDOM       | 生成一个随机数字                 |
| PS1          | Bash解释器的提示符               |
| PATH         | 定义解释器搜索用户执行命令的路径 |
| EDITOR       | 用户默认的文本编辑器             |

### Vim文本编辑器

**在Linux系统中一切都是文件，而配置一个服务就是在修改其配置文件的参数**

于Vim编辑器中设置了3种模式—命令模式、末行模式和编辑模式

~~~text
命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。

输入模式：正常的文本录入。

末行模式：保存或退出文档，以及设置编辑环境。
~~~

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/03/vim%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%BC%8F%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2.png)

表4-1                          命令模式中最常用的一些命令

| 命令 | 作用                                               |
| ---- | -------------------------------------------------- |
| dd   | 删除（剪切）光标所在整行                           |
| 5dd  | 删除（剪切）从光标处开始的5行                      |
| yy   | 复制光标所在整行                                   |
| 5yy  | 复制从光标处开始的5行                              |
| n    | 显示搜索命令定位到的下一个字符串                   |
| N    | 显示搜索命令定位到的上一个字符串                   |
| u    | 撤销上一步的操作                                   |
| p    | 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 |

行模式主要用于保存或退出文件，以及设置Vim编辑器的工作环境，还可以让用户执行外部的Linux命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中输入一个冒号就可以了。末行模式中常用的命令如表4-2所示。

表4-2                          末行模式中最常用的一些命令

| 命令          | 作用                                 |
| ------------- | ------------------------------------ |
| :w            | 保存                                 |
| :q            | 退出                                 |
| :q!           | 强制退出（放弃对文档的修改内容）     |
| :wq!          | 强制保存退出                         |
| :set nu       | 显示行号                             |
| :set nonu     | 不显示行号                           |
| :命令         | 执行该命令                           |
| :整数         | 跳转到该行                           |
| :s/one/two    | 将当前光标所在行的第一个one替换成two |
| :s/one/two/g  | 将当前光标所在行的所有one替换成two   |
| :%s/one/two/g | 将全文中的所有one替换成two           |
| ?字符串       | 在文本中从下至上搜索该字符串         |
| /字符串       | 在文本中从上至下搜索该字符串         |

可以分别使用a、i、o三个键从命令模式切换到输入模式，

在编写完之后，要想保存并退出，必须先敲击键盘的Esc键从输入模式返回命令模式

当在末行模式中输入“:wq!”命令时，就意味着强制保存并退出文档。

##### 编写shell脚本

Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。

Shell脚本命令的工作方式有下面两种。

~~~text
交互式（Interactive）：用户每输入一条命令就立即执行。

批处理（Batch）：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。
~~~

例如：

~~~
[root@linuxprobe ~]# vim example.sh
#!/bin/bash 
#For Example BY linuxprobe.com 
pwd 
ls -al
~~~

第一行的脚本声明（#!）用来告诉系统使用哪种Shell解释器来执行该脚本；第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息；第三、四行的可执行语句也就是我们平时执行的Linux命令了

内设了用于接收参数的变量，变量之间使用空格间隔。例如，$0对应的是当前Shell脚本程序的名称，$#对应的是总共有几个参数，$*对应的是所有位置的参数值，$?对应的是显示上一次命令的执行返回值，而$1、$2、$3……则分别对应着第*N*个位置的参数值，如图所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/Shell%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE%E5%8F%98%E9%87%8F.png)

例

~~~
[root@linuxprobe ~]# vim example.sh
#!/bin/bash
echo "当前脚本名称为$0"
echo "总共有$#个参数，分别是$*。"
echo "第1个参数为$1，第5个为$5。"
[root@linuxprobe ~]# bash example.sh one two three four five six
当前脚本名称为example.sh
总共有6个参数，分别是one two three four five six。
第1个参数为one，第5个为five。
~~~

##### 判断用户参数

Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回非零值。条件测试语法的执行格式如图所示。切记，条件表达式两边均应有一个空格。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5%E6%A0%BC%E5%BC%8F.png)

条件测试语句可以分四种

~~~
文件测试语句；

逻辑测试语句；

整数值比较语句；

字符串比较语句。
~~~

文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如表4-3所示。

表4-3                          文件测试所用的参数

| 操作符 | 作用                       |
| ------ | -------------------------- |
| -d     | 测试文件是否为目录类型     |
| -e     | 测试文件是否存在           |
| -f     | 判断是否为一般文件         |
| -r     | 测试当前用户是否有权限读取 |
| -w     | 测试当前用户是否有权限写入 |
| -x     | 测试当前用户是否有权限执行 |

文件测试语句来判断/etc/fstab是否为一个目录类型的文件，然后通过Shell解释器的内设$?变量显示上一条命令执行后的返回值。如果返回值为0，则目录存在；如果返回值为非零的值，则意味着它不是目录，或这个目录不存在：

~~~
[root@linuxprobe ~]# [ -d /etc/fstab ]
[root@linuxprobe ~]# echo $?
1
~~~

**一定要敲两次命令吗？**

逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在Shell终端中逻辑“与”的运算符号是&&，它表示当前面的命令执行成功后才会执行它后面的命令，因此可以用来判断/dev/cdrom文件是否存在，若存在则输出Exist字样。

~~~
[root@linuxprobe ~]# [ -e /dev/cdrom ] && echo "Exist"
Exist
~~~

逻辑“或”，它在Linux系统中的运算符号为||，表示当前面的命令执行失败后才会执行它后面的命令

逻辑语句是“非”，在Linux系统中的运算符号是一个叹号（！），它表示把条件测试中的判断结果取相反值。

~~~
&&是逻辑“与”，只有当前面的语句执行成功的时候才会执行后面的语句。
||是逻辑“或”，只有当前面的语句执行失败的时候才会执行后面的语句。
!是逻辑“非”，代表对逻辑测试结果取反值；之前若为正确则变成错误，若为错误则变成正确。
~~~

整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规范的整数比较运算符来进行操作。

表4-4                         可用的整数比较运算符

| 操作符 | 作用           |
| ------ | -------------- |
| -eq    | 是否等于       |
| -ne    | 是否不等于     |
| -gt    | 是否大于       |
| -lt    | 是否小于       |
| -le    | 是否等于或小于 |
| -ge    | 是否大于或等于 |

字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如表4-5所示。

表4-5                        常见的字符串比较运算符

| 操作符 | 作用                   |
| ------ | ---------------------- |
| =      | 比较字符串内容是否相同 |
| !=     | 比较字符串内容是否不同 |
| -z     | 判断字符串内容是否为空 |

##### 流程控制语句

###### if条件测试

if条件语句的单分支结构由if、then、fi关键词组成

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/%E5%8D%95%E5%88%86%E6%94%AF%E7%9A%84if%E8%AF%AD%E5%8F%A5.png)

if条件语句的双分支结构由if、then、else、fi关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%8F%8C%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-1.png)

if条件语句的多分支结构由if、then、else、elif、fi关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/%E5%A4%9A%E5%88%86%E6%94%AF%E7%9A%84if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5.png)

###### for条件循环语句

for循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理。当要处理的数据有范围时，使用for循环语句。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/for%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png)首先创建用户名称的列表文件users.txt，每个用户名称单独一行

~~~
[root@linuxprobe ~]# vim users.txt
andy
barry
carl
duke
eric
george
~~~

编写Shell脚本addusers.sh。在脚本中使用read命令读取用户输入的密码值，然后赋值给PASSWD变量，并通过-p参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。在执行该脚本后，会自动使用从列表文件users.txt中获取到所有的用户名称，然后逐一使用“id用户名”命令查看用户的信息，并使用$?判断这条命令是否执行成功，也就是判断该用户是否已经存在。

~~~
[root@linuxprobe ~]# vim addusers.sh
#!/bin/bash
read -p "Enter The Users Password : " PASSWD
for UNAME in `cat users.txt`
do
        id $UNAME &> /dev/null
        if [ $? -eq 0 ]
        then
                echo "$UNAME , Already exists"
        else
                useradd $UNAME
                echo "$PASSWD" | passwd --stdin $UNAME &> /dev/null
                echo "$UNAME , Create success"
        fi
done
~~~



~~~text
/dev/null是一个被称作Linux黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。
~~~

**在Linux系统中，/etc/passwd是用来保存用户账户信息的文件。**

###### while条件循环语句

让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，完全不同于for循环语句中有目标、有范围的使用场景。while循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/while%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png)

编写一个用来猜测数值大小的脚本Guess.sh。该脚本使用$RANDOM变量来调取出一个随机的数值（范围为0～32767），然后将这个随机数对1000进行取余操作，并使用expr命令取得其结果，再用这个数值与用户通过read命令输入的数值进行比较判断。这个判断语句分为3种情况，分别是判断用户输入的数值是等于、大于还是小于使用expr命令取得的数值。当前，现在这些内容不是重点，我们要关注的是while条件循环语句中的条件测试始终为true，因此判断语句会无限执行下去，直到用户输入的数值等于expr命令取得的数值后，才运行exit 0命令，终止脚本的执行。

~~~
[root@linuxprobe ~]# vim Guess.sh
#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0
echo "商品实际价格为0-999之间，猜猜看是多少？"
while true
do
        read -p "请输入您猜测的价格数目：" INT
        let TIMES++
        if [ $INT -eq $PRICE ] ; then
                echo "恭喜您答对了，实际价格是 $PRICE"
                echo "您总共猜测了 $TIMES 次"
                exit
        elif [ $INT -gt $PRICE ] ; then
                echo "太高了！"
        else
                echo "太低了！"
        fi
done
~~~

###### case条件测试

case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/case%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84.png)

###### **计划任务服务程序**

计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解。

> **一次性计划任务**：今晚23:30重启网站服务。
>
> **长期性计划任务**：每周一的凌晨3:25把/home/wwwroot目录打包备份为backup.tar.gz。

**一次性计划任务**

一次性计划任务只执行一次，一般用于临时的工作需求。可以用at命令实现这种功能，只需要写成“at时间”的形式就行。如果想要查看已设置好但还未执行的一次性计划任务，可以使用at -l命令；要想将其删除，可以使用“atrm任务序号”。at命令中的参数及其作用如表4-6所示。

表4-6                        at命令的参数及其作用

| 参数 | 作用                   |
| ---- | ---------------------- |
| -f   | 指定包含命令的任务文件 |
| -q   | 指定新任务名称         |
| -l   | 显示待执行任务列表     |
| -d   | 删除指定待执行任务     |
| -m   | 任务执行后给用户发邮件 |

在使用at命令来设置一次性计划任务时，默认采用的是交互式方法。

将系统设置为在今晚23:30自动重启网站服务。

```
[root@linuxprobe ~]# at 23:30
warning: commands will be executed using /bin/sh
at> systemctl restart httpd
at> 此处请同时按下<Ctrl>+<d>键来结束编写计划任务
job 1 at Wed Oct 14 23:30:00 2020
[root@linuxprobe ~]# at -l
1 Wed Oct 14 23:30:00 2020 a root
```

管道符（任意门）放到两条命令之间，让at命令接收前面echo命令的输出信息，以达到通过非交互式的方式创建计划一次性任务的目的。

```
[root@linuxprobe ~]# echo "systemctl restart httpd" | at 23:30
warning: commands will be executed using /bin/sh
job 2 at Wed Oct 14 23:30:00 2020
[root@linuxprobe ~]# at -l
1 Wed Oct 14 23:30:00 2020 a root
2 Wed Oct 14 23:30:00 2020 a root
```

atrm命令删除指令

**特殊场景**

把计划任务写入Shell脚本中，当用户激活该脚本后再开始倒计时执行

使用“at now +2 MINUTE”的方式进行操作，这表示2分钟（MINUTE）后执行这个任务，也可以将其替代成小时（HOUR）、日（DAY）、月（MONTH）等词汇：

```
[root@linuxprobe ~]# at now +2 MINUTE
warning: commands will be executed using /bin/sh
at> systemctl restart httpd
at> 此处请同时按下<Ctrl>+<d>键来结束编写计划任务
job 3 at Wed Oct 14 22:50:00 2020
```

**周期性计划任务**

Linux系统中默认启用的crond服务。创建、编辑计划任务的命令为crontab -e，查看当前计划任务的命令为crontab -l，删除某条计划任务的命令为crontab -r。另外，如果您是以管理员的身份登录的系统，还可以在crontab命令中加上-u参数来编辑他人的计划任务。

表4-7                        crontab命令的参数及其作用

| 参数 | 作用         |
| ---- | ------------ |
| -e   | 编辑计划任务 |
| -u   | 指定用户名称 |
| -l   | 列出任务列表 |
| -r   | 删除计划任务 |

“分、时、日、月、星期 命令”。这是使用crond服务设置任务的参数格式，需要注意的是，如果有些字段没有被设置，则需要使用星号（*****）占位。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/02/cron%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8F%82%E6%95%B0.png)

| 字段 | 说明                                     |
| ---- | ---------------------------------------- |
| 分钟 | 取值为0～59的整数                        |
| 小时 | 取值为0～23的任意整数                    |
| 日期 | 取值为1～31的任意整数                    |
| 月份 | 取值为1～12的任意整数                    |
| 星期 | 取值为0～7的任意整数，其中0与7均为星期日 |
| 命令 | 要执行的命令或程序脚本                   |

假设在每周一、三、五的凌晨3:25，都需要使用tar命令把某个网站的数据目录进行打包处理，使其作为一个备份文件。我们可以使用crontab -e命令来创建计划任务，为自己创建计划任务时无须使用-u参数。crontab –e命令的具体实现效果和crontab -l命令的结果如下所示：

```
[root@linuxprobe ~]# crontab -e
no crontab for root - using an empty one
crontab: installing new crontab
[root@linuxprobe ~]# crontab -l
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot
```

除了用逗号（,）来分别表示多个时间段，例如“8,9,12”表示8月、9月和12月。还可以用减号（-）来表示一段连续的时间周期（例如字段“日”的取值为“12-15”，则表示每月的12～15日）。还可以用除号（/）表示执行任务的间隔时间（例如“*/2”表示每隔2分钟执行一次任务）。

**如果在crond服务中需要同时包含多条计划任务的命令语句，应每行仅写一条**

在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询。

~~~
在crond服务的配置参数中，一般会像Shell脚本那样以#号开头写上注释信息，这样在日后回顾这段命令代码时可以快速了解其功能、需求以及编写人员等重要信息。

计划任务中的“分”字段必须有数值，绝对不能为空或是*号，而“日”和“星期”字段不能同时使用，否则就会发生冲突。
~~~

删除crond计划任务则非常简单，直接使用crontab -e命令进入编辑界面，删除里面的文本信息即可。也可以使用crontab -r命令直接进行删除

### 用户身份与能力

Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。

~~~
管理员UID为0：系统的管理员用户。

系统用户UID为1～999：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。

普通用户UID从1000开始：是由管理员创建的用于日常工作的用户。
~~~

为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。

在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。

~~~
基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。
~~~

##### id命令

显示用户的详细信息，语法格式为“id 用户名”。

查看用户的基本信息，例如用户ID、基本组与扩展组GID，以便于我们判别某个用户是否已经存在，以及查看相关信息。

##### useradd命令

创建新的用户账户，语法格式为“useradd [参数] 用户名”。

该命令创建用户账户时，默认的用户家目录会被存放在/home目录中，默认的[Shell](https://www.linuxcool.com/)解释器为/bin/bash，而且默认会创建一个与该用户同名的基本用户组

表5-1                    useradd命令中的参数以及作用

| 参数 | 作用                                     |
| ---- | ---------------------------------------- |
| -d   | 指定用户的家目录（默认为/home/username） |
| -e   | 账户的到期时间，格式为YYYY-MM-DD.        |
| -u   | 指定该用户的默认UID                      |
| -g   | 指定一个初始的用户基本组（必须已存在）   |
| -G   | 指定一个或多个扩展用户组                 |
| -N   | 不创建与用户同名的基本用户组             |
| -s   | 指定该用户的默认Shell解释器              |

##### groupadd命令

创建新的用户组，语法格式为“groupadd [参数] 群组名”。

##### usermod命令

修改用户的属性，英文全称为“user modify”，语法格式为“usermod [参数] 用户名”。

Linux系统中的一切都是文件，因此在系统中创建用户也就是修改配置文件的过程。用户的信息保存在/etc/passwd文件中，可以直接用文本编辑器来修改其中的用户参数项目，也可以用usermod命令修改已经创建的用户信息，比如用户的UID、基本/扩展用户组、默认终端等。usermod命令的参数以及作用如表5-2所示。

表5-2                      usermod命令中的参数以及作用

| 参数  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| -c    | 填写用户账户的备注信息                                       |
| -d -m | 参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去 |
| -e    | 账户的到期时间，格式为YYYY-MM-DD                             |
| -g    | 变更所属用户组                                               |
| -G    | 变更扩展用户组                                               |
| -L    | 锁定用户禁止其登录系统                                       |
| -U    | 解锁用户，允许其登录系统                                     |
| -s    | 变更默认终端                                                 |
| -u    | 修改用户的UID                                                |

##### passwd命令

修改用户的密码、过期时间等信息，英文全称为“password”，语法格式为“passwd [参数] 用户名”。

普通用户只能使用passwd命令修改自己的系统密码，而root管理员则有权限修改其他所有人的密码。

   passwd命令中的参数以及作用

| 参数    | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| -l      | 锁定用户，禁止其登录                                         |
| -u      | 解除锁定，允许用户登录                                       |
| --stdin | 允许通过标准输入修改用户密码，如echo "NewPassWord" \| passwd --stdin Username |
| -d      | 使该用户可用空密码登录系统                                   |
| -e      | 强制用户在下次登录时修改密码                                 |
| -S      | 显示用户的密码是否被锁定，以及密码所采用的加密算法名称       |

##### userdel命令

删除已有的用户账户，英文全称为“user delete”，语法格式为“userdel [参数] 用户名”。

表5-4                       userdel命令中的参数以及作用

| 参数 | 作用                     |
| ---- | ------------------------ |
| -f   | 强制删除用户             |
| -r   | 同时删除用户及用户家目录 |

在删除一个用户时，一般会建议保留他的家目录数据，以免有重要的数据被误删除。所以在使用userdel命令时可以不加参数，写清要删除的用户名称就行

### 文件权限与归属

“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个[脚本](https://www.linuxcool.com/)程序。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。

  读写执行权限对于文件与目录可执行命令的区别

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E8%AF%BB%E5%86%99%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E5%AF%B9%E4%BA%8E%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8-1024x168.png)

文件的可读、可写、可执行权限的英文全称分别是read、write、execute，可以简写为r、w、x，亦可分别用数字4、2、1来表示，文件所有者、文件所属组及其他用户权限之间无关联，如表5-6所示。

表5-6                       文件权限的字符与数字表示

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%8E%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA-1024x201.png)

以rw-r-x-w-权限为例来介绍如何将字符表示的权限转换为数字表示的权限

![image-20220722110440523](C:\Users\Xlibi\AppData\Roaming\Typora\typora-user-images\image-20220722110440523.png)

![image-20220722110329093](C:\Users\Xlibi\AppData\Roaming\Typora\typora-user-images\image-20220722110329093.png)

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E6%9D%83%E9%99%90%E8%BD%AC%E6%8D%A2-300x136.jpg)

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2015/02/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png)

包含了文件的类型、访问权限、所有者（属主）、所属组（属组）、占用的磁盘大小、最后修改时间和文件名称等信息。通过分析可知，该文件的类型为普通文件，所有者权限为可读、可写（rw-），所属组权限为可读（r--），除此以外的其他人也只有可读权限（r--），文件的磁盘占用大小是34298字节，最近一次的修改时间为4月2日的0:23，文件的名称为install.log。

常见的文件类型包括普通文件（-）、目录文件（d）、链接文件（l）、管道文件（p）、块设备文件（b）以及字符设备文件（c）。

![image-20220722111457809](C:\Users\Xlibi\AppData\Roaming\Typora\typora-user-images\image-20220722111457809.png)

### 文件的特殊权限

单纯设置文件的rwx权限无法满足我们对安全和灵活性的需求，因此便有了SUID、SGID与SBIT的特殊权限位。这是一种对文件权限进行设置的特殊功能，可以与一般权限同时使用，以弥补一般权限不能实现的功能。

##### SUID

SUID是一种对二进制程序进行设置的特殊权限，能够让二进制程序的执行者临时拥有所有者的权限（仅对拥有执行权限的二进制程序有效）。

##### SGID

当对二进制程序进行设置时，能够让执行者临时获取文件所属组的权限；当对目录进行设置时，则是让目录内新创建的文件自动继承该目录原有用户组的名称。

chmod命令用于设置文件的一般权限及特殊权限，英文全称为“change mode”，语法格式为“chmod [参数] 文件名”。

这是一个与文件权限的日常设置强相关的命令。例如，要把一个文件的权限设置成其所有者可读可写可执行、所属组可读可写、其他人没有任何权限，则相应的字符法表示为rwxrw----，其对应的数字法表示为760。

chown命令用于设置文件的所有者和所有组，英文全称为change own，语法格式为“chown所有者:所有组 文件名”。

chmod和chown命令是用于修改文件属性和权限的最常用命令，它们还有一个特别的共性，就是针对目录进行操作时需要加上大写参数-R来表示递归操作，即对目录内所有的文件进行整体操作。

##### SBIT

SBIT特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。换句话说，当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者执行删除操作了。

表5-7                     SUID、SGID、SBIT特殊权限的设置参数

| 参数 | 作用         |
| ---- | ------------ |
| u+s  | 设置SUID权限 |
| u-s  | 取消SUID权限 |
| g+s  | 设置SGID权限 |
| g-s  | 取消SGID权限 |
| o+t  | 设置SBIT权限 |
| o-t  | 取消SBIT权限 |

SUID、SGID与SBIT也有对应的数字表示法，分别为4、2、1


![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90%E6%95%B0%E5%AD%97%E6%B3%95%E8%AE%A1%E7%AE%97-300x244.jpg)

图5-4 权限的字符表示法转数字表示法

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90%E5%AD%97%E7%AC%A6%E6%B3%95%E8%AE%A1%E7%AE%97-1-300x223.jpg)

图5-5 权限的数字表示法转字符标识法

### 文件的隐藏属性

#### chattr命令

设置文件的隐藏权限，英文全称为change attributes，语法格式为“chattr [参数] 文件名称”。

  chattr命令中的参数及其作用。如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”

| 参数 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| i    | 无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件 |
| a    | 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）     |
| S    | 文件内容在变更后立即同步到硬盘（sync）                       |
| s    | 彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）      |
| A    | 不再修改这个文件或目录的最后访问时间（atime）                |
| b    | 不再修改文件或目录的存取时间                                 |
| D    | 检查压缩文件中的错误                                         |
| d    | 使用dump命令备份时忽略本文件/目录                            |
| c    | 默认将文件或目录进行压缩                                     |
| u    | 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复         |
| t    | 让文件系统支持尾部合并（tail-merging）                       |
| x    | 可以直接访问压缩文件中的内容                                 |

#### lsattr命令

查看文件的隐藏权限，英文全称为“list attributes”，语法格式为“lsattr [参数] 文件名称”。

### 文件访问控制列表

如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。通俗来讲，基于普通文件或目录设置ACL其实就是针对指定的用户或用户组设置文件或目录的操作权限，更加精准地派发权限。另外，如果针对某个目录设置了ACL，则目录中的文件会继承其ACL权限；若针对文件设置了ACL，则文件不再继承其所在目录的ACL权限。

#### setfacl命令

管理文件的ACL权限规则，英文全称为“set files ACL”，语法格式为“setfacl [参数] 文件名称”。

ACL权限提供的是在所有者、所属组、其他人的读/写/执行权限之外的特殊权限控制。使用setfacl命令可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。其中，针对目录文件需要使用-R递归参数；针对普通文件则使用-m参数；如果想要删除某个文件的ACL，则可以使用-b参数。setfacl命令的常用参数如表5-9所示。

表5-9                       setfacl命令中的参数以及作用

| 参数 | 作用             |
| ---- | ---------------- |
| -m   | 修改权限         |
| -M   | 从文件中读取权限 |
| -x   | 删除某个权限     |
| -b   | 删除全部权限     |
| -R   | 递归子目录       |

#### getfacl命令

查看文件的ACL权限规则，英文全称为“get files ACL”，语法格式为“getfacl [参数] 文件名称”。

允许某个组的用户都可以读写/etc/fstab文件：

```
setfacl -m g:linuxprobe:rw /etc/fstab
```

要清空所有ACL权限，请用-b参数；要删除某一条指定的权限，就用-x参数：ACL权限的恢复也很简单，使用的是--restore参数。

#### su命令与sudo命令

的su命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。

当从root管理员切换到普通用户时是不需要密码验证的，而从普通用户切换成root管理员就需要进行密码验证了

sudo命令用于给普通用户提供额外的权限，语法格式为“sudo [参数] 用户名”。

表5-10                     sudo命令中的可用参数以及作用

| 参数             | 作用                                                   |
| ---------------- | ------------------------------------------------------ |
| -h               | 列出帮助信息                                           |
| -l               | 列出当前用户可执行的命令                               |
| -u 用户名或UID值 | 以指定的用户身份执行命令                               |
| -k               | 清空密码的有效时间，下次执行sudo时需要再次进行密码验证 |
| -b               | 在后台执行指定的命令                                   |
| -p               | 更改询问密码的提示语                                   |

如果担心直接修改配置文件会出现问题，则可以使用sudo命令提供的visudo命令来配置用户权限。

visudo命令用于编辑、配置用户sudo的权限文件，语法格式为“visudo [参数]”。

这是一条会自动调用vi编辑器来配置/etc/sudoers权限文件的命令，能够解决多个用户同时修改权限而导致的冲突问题。不仅如此，visudo命令还可以对配置文件内的参数进行语法检查，并在发现参数错误时进行报错提醒。这要比用户直接修改文件更友好、安全、方便。

。在配置权限文件时，按照下面的格式在第101行（大约）填写上指定的信息。

> **谁可以使用 允许使用的主机 = （以谁的身份） 可执行命令的列表**
>
> **谁可以使用：**稍后要为哪位用户进行命令授权。
>
> **允许使用的主机：**可以填写ALL表示不限制来源的主机，亦可填写如192.168.10.0/24这样的网段限制来源地址，使得只有从允许网段登录时才能使用sudo命令。
>
> **以谁的身份：**可以填写ALL表示系统最高权限，也可以是另外一位用户的名字。
>
> **可执行命令的列表：**可以填写ALL表示不限制命令，亦可填写如/usr/bin/cat这样的文件名称来限制命令列表，多个命令文件之间用逗号（,）间隔。



### 存储结构

Linux系统中的文件和目录名称是严格区分大小写的。例如，root、rOOt、Root、rooT均代表不同的目录，并且文件名称中不得包含斜杠（/）

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2015/02/Linux%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84.png)

表6-1                 Linux系统中常见的目录名称以及相应内容

| 目录名称    | 应放置文件的内容                                             |
| ----------- | ------------------------------------------------------------ |
| /boot       | 开机所需文件—内核、开机菜单以及所需配置文件等                |
| /dev        | 以文件形式存放任何设备与接口                                 |
| /etc        | 配置文件                                                     |
| /home       | 用户主目录                                                   |
| /bin        | 存放单用户模式下还可以操作的[命令](https://www.linuxcool.com/) |
| /lib        | 开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数    |
| /sbin       | 开机过程中需要的命令                                         |
| /media      | 用于挂载设备文件的目录                                       |
| /opt        | 放置第三方的软件                                             |
| /root       | 系统管理员的家目录                                           |
| /srv        | 一些网络服务的数据文件目录                                   |
| /tmp        | 任何人均可使用的“共享”临时目录                               |
| /proc       | 虚拟文件系统，例如系统内核、进程、外部设备及网络状态等       |
| /usr/local  | 用户自行安装的软件                                           |
| /usr/sbin   | Linux系统开机时不会使用到的软件/命令/[脚本](https://www.linuxcool.com/) |
| /usr/share  | 帮助与说明文件，也可放置共享文件                             |
| /var        | 主要存放经常变化的文件，如日志                               |
| /lost+found | 当文件系统发生错误时，将一些丢失的文件片段存放在这里         |

**绝对路径相对路径**

~~~
绝对路径（absolute path）：首先坐飞机来到中国，到了北京后出首都机场，坐机场快轨到三元桥，然后换乘10号线到潘家园站，出站后坐34路公交车到农光里，下车后路口左转。

相对路径（relative path）：前面路口左转。
~~~

#### 物理设备命名规则

udev设备管理器的服务会一直以守护进程的形式运行并侦听内核发出的信号来管理/dev目录下的设备文件。

Linux系统中常见的硬件设备及其文件名称如表6-2所示。

表6-2                       常见的硬件设备及其文件名称

| 硬件设备      | 文件名称           |
| ------------- | ------------------ |
| IDE设备       | /dev/hd[a-d]       |
| SCSI/SATA/U盘 | /dev/sd[a-z]       |
| virtio设备    | /dev/vd[a-z]       |
| 软驱          | /dev/fd[0-1]       |
| 打印机        | /dev/lp[0-15]      |
| 光驱          | /dev/cdrom         |
| 鼠标          | /dev/mouse         |
| 磁带机        | /dev/st0或/dev/ht0 |

由于现在的IDE设备已经很少见了，所以一般的硬盘设备都是以“/dev/sd”开头。而一台主机上可以有多块硬盘，因此系统采用a～z来代表26块不同的硬盘（默认从a开始分配），而且硬盘的分区编号也很有讲究：

> 主分区或扩展分区的编号从1开始，到4结束；
>
> 逻辑分区从编号5开始。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2015/02/%E7%A1%AC%E7%9B%98%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99.png)

硬盘设备是由大量的扇区组成的，每个扇区的容量为512字节。其中第一个扇区最重要，它里面保存着主引导记录与分区表信息。就第一个扇区来讲，主引导记录需要占用446字节，分区表占用64字节，结束符占用2字节；其中分区表中每记录一个分区信息就需要16字节，这样一来最多只有4个分区信息可以写到第一个扇区中，这4个分区就是4个主分区。第一个扇区中的数据信息如图6-3所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%89%87%E5%8C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF-1.jpg)

#### 文件系统与数据资料

Linux系统支持数十种文件系统，而最常见的文件系统如下所示。

**Ext2**：最早可追溯到1993年，是Linux系统的第一个商业级文件系统，它基本沿袭了UNIX文件系统的设计标准。但由于不包含日志读写功能，数据丢失的可能性很大，因此大家能不用就不用，或者顶多建议用于SD存储卡或U盘。

**Ext3**：是一款日志文件系统，它会把整个硬盘的每个写入动作的细节都预先记录下来，然后再进行实际操作，以便在发生异常宕机后能回溯追踪到被中断的部分。Ext3能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也会很长，而且也不能100%地保证资料不会丢失。

**Ext4**：Ext3的改进版本，作为RHEL 6系统中默认的文件管理系统，它支持的存储容量高达1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4文件系统能够批量分配block（块），从而极大地提高了读写效率。现在很多主流服务器也会使用Ext4文件系统。

**XFS**：是一种高性能的日志文件系统，而且是RHEL 7/8中默认的文件管理系统。它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的日志功能只需花费极低的计算和存储性能。它支持的最大存储容量为18EB，这几乎满足了所有需求。

在拿到一块新的硬盘存储设备后，先需要分区，然后再格式化文件系统，最后才能挂载并正常使用。硬盘的分区操作取决于您的需求和硬盘大小；也可以选择不进行分区，但是必须对硬盘进行格式化处理。

#### 挂载硬件设备

当用户需要使用硬盘设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就是“挂载”。

mount命令用于挂载文件系统，格式为“mount文件系统 挂载目录”。

表6-3                       mount命令中的参数以及作用

| 参数 | 作用                                 |
| ---- | ------------------------------------ |
| -a   | 挂载所有在/etc/fstab中定义的文件系统 |
| -t   | 指定文件系统的类型                   |

要挂载一块网络存储设备，该设备的名字可能会变来变去，推荐用UUID（Universally Unique Identifier，通用唯一识别码）进行挂载操作。UUID是一串用于标识每块独立硬盘的字符串，具有唯一性及稳定性。

blkid命令用于显示设备的属性信息，英文全称为“block id”，语法格式为“blkid [设备名]”。

系统在重启后挂载就会失效，也就是说需要每次开机后都手动挂载一下如果想让硬件设备和目录永久地进行自动关联，就必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”（各字段的意义见表6-4）写入到/etc/fstab文件中。这个文件中包含着挂载所需的诸多信息项目，一旦配置好之后就能一劳永逸了。

表6-4            用于挂载信息的指定填写格式中，各字段所表示的意义

| 字段     | 意义                                                         |
| -------- | ------------------------------------------------------------ |
| 设备文件 | 一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier） |
| 挂载目录 | 指定要挂载到的目录，需在挂载前创建好                         |
| 格式类型 | 指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等 |
| 权限选项 | 若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async |
| 是否备份 | 若为1则开机后使用dump进行磁盘备份，为0则不备份               |
| 是否自检 | 若为1则开机后自动进行磁盘自检，为0则不自检                   |

写入到/etc/fstab文件中的设备信息并不会立即生效，需要使用mount -a参数进行自动挂载

想查看当前系统中设备的挂载情况，使用df命令。能够列出系统中正在使用的设备有哪些，可以用-h参数便捷地对存储容量进行“进位”操作

挂载文件系统的目的是为了使用硬件资源，而卸载文件系统则意味不再使用硬件的设备资源。既然挂载操作就是把硬件设备与目录两者进行关联的动作，那么卸载操作只需要说明想要取消关联的设备文件或挂载目录的其中一项即可，一般不需要加其他额外的参数。

umount命令用于卸载设备或文件系统，英文全称为“un mount”，语法格式为“umount [设备文件/挂载目录]”。

lsblk命令用于查看已挂载的磁盘的空间使用情况，英文全称为“list block id”，输入该命令后按回车键执行即可。

#### 添加硬盘设备

fdisk命令用于新建、修改及删除磁盘的分区表信息，英文全称为“format disk”，语法格式为“fdisk磁盘名称”。

表6-5                       fdisk命令中的参数以及作用

| 参数 | 作用                   |
| ---- | ---------------------- |
| m    | 查看全部可用的参数     |
| n    | 添加新的分区           |
| d    | 删除某个分区信息       |
| l    | 列出所有可用的分区类型 |
| t    | 改变某个分区的类型     |
| p    | 查看分区表信息         |
| w    | 保存并退出             |
| q    | 不保存直接退出         |

如果硬件存储设备没有进行格式化，则Linux系统无法得知怎么在其上写入数据。因此，在对存储设备进行分区后还需要进行格式化操作。在Linux系统中用于格式化操作的命令是mkfs。

du命令用查看分区或目录所占用的磁盘容量大小，英文全称为“disk usage”，语法格式为“du -sh目录名称”。

#### 添加交换分区

交换（SWAP）分区是一种通过在硬盘中预先划分一定的空间，然后把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。通俗来讲就是让硬盘帮内存分担压力。但由于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。

mkswap命令用于对新设备进行交换分区格式化，英文全称为“make swap”，语法格式为“mkswap设备名称”。

```
[root@linuxprobe ~]# mkswap /dev/sdb2
Setting up swapspace version 1, size = 5 GiB (5368705024 bytes)
no label, UUID=45a4047c-49bf-4c88-9b99-f6ac93908485
```

swapon命令用于激活新的交换分区设备，英文全称为“swap on”，语法格式为“swapon设备名称”。

使用swapon命令把准备好的SWAP硬盘设备正式挂载到系统中。可以使用free -m命令查看交换分区的大小变化（由2047MB增加到7167MB）：

```
[root@linuxprobe ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1966        1391         105          12         469         384
Swap:          2047           9        2038
[root@linuxprobe ~]# swapon /dev/sdb2
[root@linuxprobe ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1966        1395         101          12         469         380
Swap:          7167           9        7158
```

#### 磁盘容量配额

盘容量配额服务来限制某位用户或某个用户组针对特定文件夹可以使用的最大硬盘空间或最大文件个数，一旦达到这个最大值就不再允许继续使用。可以使用quota技术进行磁盘容量配额管理，从而限制用户的硬盘可用容量或所能创建的最大文件个数。quota技术还有软限制和硬限制的功能。

> **软限制**：当达到软限制时会提示用户，但仍允许用户在限定的额度内继续使用。
>
> **硬限制**：当达到硬限制时会提示用户，且强制终止用户的操作。

xfs_quota命令用于管理设备的磁盘容量配额，语法格式为“xfs_quota [参数] 配额 文件系统”。

这是一个专门针对XFS文件系统来管理quota磁盘容量配额服务而设计的命令。其中，-c参数用于以参数的形式设置要执行的命令；-x参数是专家模式，让运维人员能够对quota服务进行更多复杂的配置。

isoft和ihard就是通过限制系统最大使用的inode个数来限制了文件数量。bsoft和bhard则是代表文件所占用的block大小，也就是文件占用的最大容量的总统计。

soft是软限制，超过该限制后也只是将操作记录写到日志中，不对用户行为进行限制。而hard是硬限制，一旦超过系统就会马上禁止，用户再也不能创建或新占任何的硬盘容量。

edquota命令用于管理系统的磁盘配额，英文全称为“edit quota”，语法格式为“edquota [参数] 用户名”。

在为用户设置了quota磁盘容量配额限制后，可以使用edquota命令按需修改限额的数值。其中，-u参数表示要针对哪个用户进行设置；-g参数表示要针对哪个用户组进行设置，如表6-6所示。

表6-6                       edquota命令中可用的参数以及作用

| 参数 | 作用                        |
| ---- | --------------------------- |
| -u   | 对某个用户进行设置          |
| -g   | 对某个用户组进行设置        |
| -p   | 复制原有的规则到新的用户/组 |
| -t   | 限制宽限期限                |

#### VDO虚拟数据优化

一种通过压缩或删除存储设备上的数据来优化存储空间的技术。

关键就是对硬盘内原有的数据进行删重操作，它有点类似于我们平时使用的网盘服务，在第一次正常上传文件时速度特别慢，在第二次上传相同的文件时仅作为一个数据指针，几乎可以达到“秒传”的效果，无须再多占用一份空间，也不用再漫长等待。除了删重操作，VDO技术还可以对日志和数据库进行自动压缩，进一步减少存储浪费的情况。

表6-7                      对各种类型文件压缩效果汇总表

| 文件名  | 描述                            | 类型              | 原始大小（KB） | 实际占用空间（KB） |
| ------- | ------------------------------- | ----------------- | -------------- | ------------------ |
| dickens | 狄更斯文集                      | 英文原文          | 9953           | 9948               |
| mozilla | Mozilla的1.0可执行文件          | 执行程序          | 50020          | 33228              |
| mr      | 医用resonanse图像               | 图片              | 9736           | 9272               |
| nci     | 结构化的化学数据库              | 数据库            | 32767          | 10168              |
| ooffice | Open Office.org 1.01 DLL        | 可执行程序        | 6008           | 5640               |
| osdb    | 基准测试用的MySQL格式示例数据库 | 数据库            | 9849           | 9824               |
| reymont | 瓦迪斯瓦夫·雷蒙特的书           | PDF               | 6471           | 6312               |
| samba   | samba源代码                     | src源码           | 21100          | 11768              |
| sao     | 星空数据                        | 天文格式的bin文件 | 7081           | 7036               |
| webster | 辞海                            | HTML              | 40487          | 40144              |
| xml     | XML文件                         | HTML              | 5220           | 2180               |
| x-ray   | 透视医学图片                    | 医院数据          | 8275           | 8260               |

VDO技术支持本地存储和远程存储，可以作为本地文件系统、iSCSI或Ceph存储下的附加存储层使用。在部署虚拟机或容器时，建议采用逻辑存储与物理存储为10∶1的比例进行配置，即1TB物理存储对应10TB逻辑存储；而部署对象存储时 （例如使用Ceph）则采用逻辑存储与物理存储为3∶1的比例进行配置，即使用1TB物理存储对应3TB逻辑存储。

简而言之，VDO技术能省空间！

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/VDO.jpg)

dm-crypt之类的技术是可以与VDO技术兼容的，但记得要先对卷进行加密再使用VDO。因为加密会使重复的数据变得有所不同，因此删重操作无法实现。VDO技术不可叠加使用，1TB的物理存储提升成10TB的逻辑存储没问题，但是再用10TB翻成100TB就不行了。

所用的系统没有安装VDO的话也不要着急，用dnf命令即可完成安装

```
dnf install kmod-kvdo vdo
```

首先，创建一个全新的VDO卷。

新添加进来的物理设备就是使用vdo命令来管理的，其中name参数代表新的设备卷的名称；device参数代表由哪块磁盘进行制作；vdoLogicalSize参数代表制作后的设备大小。依据红帽公司推荐的原则，20GB硬盘将翻成200GB的逻辑存储

```
vdo create --name=storage --device=/dev/sdc --vdoLogicalSize=200G
```

使用status参数查看新建卷的概述信息

```
vdo status --name=storage
```

在输出信息中包含了VDO卷创建的时间、主机名、版本、是否压缩（Compression）及是否删重（Deduplication）等关键信息

对新建卷进行格式化操作并挂载使用。

新建的VDO卷设备会被乖乖地存放在/dev/mapper目录下，并以设备名称命名，对它操作就行。另外，挂载前可以用udevadm settle命令对设备进行一次刷新操作，避免刚才的配置没有生效

```
mkfs.xfs /dev/mapper/storage 
[root@linuxprobe ~]# udevadm settle
[root@linuxprobe ~]# mkdir /storage
[root@linuxprobe ~]# mount /dev/mapper/storage /storage
```

如果想查看设备的实际使用情况，使用vdostats命令即可。human-readable参数的作用是将存储容量自动进位，以人们更易读的方式输出（比如，显示20G而不是20971520K）：

```
[root@linuxprobe ~]# vdostats --human-readable
```

#### 软硬方式链接

Linux系统中存在软链接和硬链接两种不同的类型。

**软链接（soft link）：**也叫符号链接（symbolic link），仅仅包含所链接文件的名称和路径，很像一个记录地址的标签。当原始文件被删除或移动后，新的链接文件也会随之失效，不能被访问。可以针对文件、目录设置软链接，跨文件系统进行链接也不是问题。从这一点来看，它与Windows系统的“快捷方式”具有一样的性质。用户访问软链接的效果如图6-15所示。

**硬链接（hard link）：**可以将它理解为一个“指向原始文件block的指针”，系统会创建出一个与原来一模一样的inode信息块。所以，硬链接文件与原始文件其实是一模一样的，只是名字不同。每添加一个硬链接，该文件的inode个数就会增加1；而且只有当该文件的inode个数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件block的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，不能跨分区对目录文件进行硬链接。用户访问硬链接的效果如图6-16所示

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E8%BD%AF%E9%93%BE%E6%8E%A5.jpg)

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E7%A1%AC%E9%93%BE%E6%8E%A5.jpg)

ln命令用于创建文件的软硬链接，英文全称为“link”，语法格式为“ln [参数]原始文件名 链接文件名”。

ln命令的可用参数以及作用如表6-8所示。在使用ln命令时，是否添加-s参数，将创建出性质不同的两种“快捷方式”。

表6-8                       ln命令中可用的参数以及作用

| 参数 | 作用                                               |
| ---- | -------------------------------------------------- |
| -s   | 创建“符号链接”（如果不带-s参数，则默认创建硬链接） |
| -f   | 强制创建文件或目录的链接                           |
| -i   | 覆盖前先询问                                       |
| -v   | 显示创建链接的过程                                 |

### RAID与LVM磁盘阵列技术

AID技术通过把多个硬盘设备组合成一个容量更大、安全性更好的磁盘阵列，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用分散读写技术来提升磁盘阵列整体的性能，同时把多个重要数据的副本同步到不同的物理硬盘设备上，从而起到了非常好的数据冗余备份效果。

  RAID 0、1、5、10方案技术对比

| RAID级别 | 最少硬盘 | 可用容量 | 读写性能 | 安全性 | 特点                                                         |
| -------- | -------- | -------- | -------- | ------ | ------------------------------------------------------------ |
| 0        | 2        | n        | n        | 低     | 追求最大容量和速度，任何一块盘损坏，数据全部异常。           |
| 1        | 2        | n/2      | n        | 高     | 追求最大安全性，只要阵列组中有一块硬盘可用，数据不受影响。   |
| 5        | 3        | n-1      | n-1      | 中     | 在控制成本的前提下，追求硬盘的最大容量、速度及安全性，允许有一块硬盘异常，数据不受影响。 |
| 10       | 4        | n/2      | n/2      | 高     | 综合RAID1和RAID0的优点，追求硬盘的速度和安全性，允许有一半硬盘异常（不可同组），数据不受影响 |

#### RAID 0

多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成一个大的卷组，并将数据依次写入各个物理硬盘中，有效地提升硬盘数据的吞吐速度，但是不具备数据备份和错误修复能力

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/RAID-0-1.jpg)

#### RAID 1

如果生产环境对硬盘设备的读写速度没有要求，而是希望增加数据的安全性时，就需要用到RAID 1,把两块以上的硬盘设备进行绑定，在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备份）。当其中某一块硬盘发生故障后，一般会立即自动以热交换的方式来恢复数据的正常使用。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/RAID-1-1.jpg)

#### RAID 5

把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。实际上没有备份硬盘中的真实数据信息，而是当硬盘设备出现问题后通过奇偶校验信息来尝试重建损坏的数据。RAID这样的技术特性“妥协”地兼顾了硬盘设备的读写速度、数据安全性与存储成本问题。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/RAID-5-1.jpg)

RAID 5最少由3块硬盘组成，使用的是硬盘切割（Disk Striping）技术。相较于RAID 1级别，好处就在于保存的是奇偶校验信息而不是一模一样的文件内容，所以当重复写入某个文件时，RAID 5级别的磁盘阵列组只需要对应一个奇偶校验信息就可以，效率更高，存储成本也会随之降低。

#### RAID 10

RAID 10技术是RAID 1+RAID 0技术的一个“组合体”,需要至少4块硬盘来组建，其中先分别两两制作成RAID 1磁盘阵列，以保证数据的安全性；然后再对两个RAID 1磁盘阵列实施RAID 0技术，进一步提高硬盘设备的读写速度。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/RAID-10-2.jpg)

#### 磁盘阵列

mdadm[命令](https://www.linuxcool.com/)用于创建、调整、监控和管理RAID设备，英文全称为“multiple devices admin”，语法格式为“mdadm参数 硬盘名称”。

mdadm命令中的常用参数及作用如表7-2所示。

表7-2                      mdadm命令的常用参数和作用

| 参数 | 作用             |
| ---- | ---------------- |
| -a   | 检测设备名称     |
| -n   | 指定设备数量     |
| -l   | 指定RAID级别     |
| -C   | 创建             |
| -v   | 显示过程         |
| -f   | 模拟设备损坏     |
| -r   | 移除设备         |
| -Q   | 查看摘要信息     |
| -D   | 查看详细信息     |
| -S   | 停止RAID磁盘阵列 |

-C参数代表创建一个RAID阵列卡；-v参数显示创建的过程，同时在后面追加一个设备名称/dev/md0，这样/dev/md0就是创建后的RAID磁盘阵列的名称；-n 4参数代表使用4块硬盘来部署这个RAID磁盘阵列；而-l 10参数则代表RAID 10方案；最后再加上4块硬盘设备的名称就搞定了。

```
[root@linuxprobe ~]# mdadm -Cv /dev/md0 -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde
```

之后格式化，挂载，信息添加/etc/fstab文件。

#### 损坏磁盘阵列及修复

在确认有一块物理硬盘设备出现损坏而不能再继续正常使用后，应该使用mdadm命令将其移除，然后查看RAID磁盘阵列的状态，

在RAID 10级别的磁盘阵列中，当RAID 1磁盘阵列中存在一个故障盘时并不影响RAID 10磁盘阵列的使用。当购买了新的硬盘设备后再使用mdadm命令予以替换即可，在此期间可以在/RAID目录中正常地创建或删除文件。由于我们是在虚拟机中模拟硬盘，所以先重启系统，然后再把新的硬盘添加到RAID磁盘阵列中。

更换硬盘后再次使用-a参数进行添加操作，系统默认会自动开始数据的同步工作。使用-D参数即可看到整个过程和进度

#### 磁盘阵列+备份盘

该技术的核心理念就是准备一块足够大的硬盘，这块硬盘平时处于闲置状态，一旦RAID磁盘阵列中有硬盘出现故障后则会马上自动顶替上去

#### 删除磁盘阵列

首先，需要将所有的磁盘都设置成停用状态：

```
[root@linuxprobe ~]# umount /RAID
[root@linuxprobe ~]# mdadm /dev/md0 -f /dev/sdc
```

然后再逐一移除出去：

```
[root@linuxprobe ~]# mdadm /dev/md0 -r /dev/sdb
mdadm: hot removed /dev/sdb from /dev/md0
[root@linuxprobe ~]# mdadm /dev/md0 -r /dev/sdc
mdadm: hot removed /dev/sdc from /dev/md0
[root@linuxprobe ~]# mdadm /dev/md0 -r /dev/sdd
mdadm: hot removed /dev/sdd from /dev/md0
[root@linuxprobe ~]# mdadm /dev/md0 -r /dev/sde
mdadm: hot removed /dev/sde from /dev/md0
```

也可以用“mdadm /dev/md0 -f /dev/sdb -r /dev/sdb”这一条命令搞定

#### LVM逻辑卷管理器

逻辑卷管理器（Logical Volume Manager，LVM）。LVM允许用户对硬盘资源进行动态调整。

LVM技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并。这样一来，用户不必关心物理硬盘设备的底层架构和布局，就可以实现对硬盘分区的动态调整。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%E5%99%A8-1.jpg)

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%E6%9C%9F%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE-1-295x300.jpg)

物理卷处于LVM中的最底层，可以将其理解为物理硬盘、硬盘分区或者RAID磁盘阵列。卷组建立在物理卷之上，一个卷组能够包含多个物理卷，而且在卷组创建之后也可以继续向其中添加新的物理卷。逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间。这就是LVM的核心理念。

#### 部署逻辑卷

部署时，需要逐个配置物理卷、卷组和逻辑卷，常用的部署命令如表7-3所示。

表7-3                          常用的LVM部署命令

| 功能/命令 | 物理卷管理 | 卷组管理  | 逻辑卷管理 |
| --------- | ---------- | --------- | ---------- |
| 扫描      | pvscan     | vgscan    | lvscan     |
| 建立      | pvcreate   | vgcreate  | lvcreate   |
| 显示      | pvdisplay  | vgdisplay | lvdisplay  |
| 删除      | pvremove   | vgremove  | lvremove   |
| 扩展      |            | vgextend  | lvextend   |
| 缩小      |            | vgreduce  | lvreduce   |

我们先对这两块新硬盘进行创建物理卷的操作，可以将该操作简单理解成让硬盘设备支持LVM技术，或者理解成是把硬盘设备加入到LVM技术可用的硬件资源池中，然后对这两块硬盘进行卷组合并，卷组的名称允许由用户自定义。接下来，根据需求把合并后的卷组切割出一个约为150MB的逻辑卷设备，最后把这个逻辑卷设备格式化成Ext4文件系统后挂载使用。

让新添加的两块硬盘设备支持LVM技术。

```
[root@linuxprobe ~]# pvcreate /dev/sdb /dev/sdc
```

把两块硬盘设备加入到storage卷组中，然后查看卷组的状态。

```
[root@linuxprobe ~]# vgcreate storage /dev/sdb /dev/sdc
```

再切割出一个约为150MB的逻辑卷设备。

这里需要注意切割单位的问题。在对逻辑卷进行切割时有两种计量单位。第一种是以容量为单位，所使用的参数为-L。例如，使用-L 150M生成一个大小为150MB的逻辑卷。另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。

```
[root@linuxprobe ~]# lvcreate -n vo -l 37 storage
```

把生成好的逻辑卷进行格式化，然后挂载使用。

如果使用了逻辑卷管理器，则不建议用XFS文件系统，因为XFS文件系统自身就可以使用xfs_growfs命令进行磁盘扩容。这虽然不比LVM灵活，但起码也够用。在实测阶段我们发现，在有一些服务器上，XFS与LVM的兼容性并不好。

#### 扩容逻辑卷

把上一个实验中的逻辑卷vo扩展至290MB。检查硬盘的完整性，确认目录结构、内容和文件内容没有丢失。一般情况下没有报错，均为正常情况。

重置设备在系统中的容量。刚刚是对LV（逻辑卷）设备进行了扩容操作，但系统内核还没有同步到这部分新修改的信息，需要手动进行同步。

重新挂载硬盘设备并查看挂载状态。

#### 缩小逻辑卷

#### 逻辑卷快照

使用-s参数生成一个快照卷，使用-L参数指定切割的大小，需要与要做快照的设备容量保持一致。另外，还需要在命令后面写上是针对哪个逻辑卷执行的快照操作，稍后数据也会还原到这个相应的设备上。

#### 删除逻辑卷

需要执行LVM的删除操作。为此，需要提前备份好重要的数据信息，然后依次删除逻辑卷、卷组、物理卷设备，这个顺序不可颠倒。

**第1步**：取消逻辑卷与目录的挂载关联，删除配置文件中永久生效的设备参数。

**第2步**：删除逻辑卷设备，需要输入y来确认操作。

**第3步**：删除卷组，此处只写卷组名称即可，不需要设备的绝对路径。

**第4步**：删除物理卷设备。

### 使用lptables与Firewalld防火墙

#### 防火墙管理工具

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E9%98%B2%E7%81%AB%E5%A2%99%E4%BD%9C%E4%B8%BA%E5%85%AC%E7%BD%91%E4%B8%8E%E5%86%85%E7%BD%91%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BF%9D%E6%8A%A4%E5%B1%8F%E9%9A%9C-2.jpg)

防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。

iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。

#### lptables策略与规则链

防火墙会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。一般而言，防火墙策略规则的设置有两种：“通”（即放行）和“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。

iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：

> 在进行路由选择前处理数据包（PREROUTING）；
>
> 处理流入的数据包（INPUT）；
>
> 处理流出的数据包（OUTPUT）；
>
> 处理转发的数据包（FORWARD）；
>
> 在进行路由选择后处理数据包（POSTROUTING）。

一般来说，从内网向外网发送的流量一般都是可控且良性的，因此使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。

iptables服务的术语中分别是ACCEPT（允许流量通过）、REJECT（拒绝流量通过）、LOG（记录日志信息）、DROP（拒绝流量通过）。“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。

#### lptables基本命令参数

iptables属于数据链路层的服务，所以可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配；一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。

防火墙策略规则的匹配顺序是从上到下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。

表8-1                      iptables中常用的参数以及作用

| 参数        | 作用                                         |
| ----------- | -------------------------------------------- |
| -P          | 设置默认策略                                 |
| -F          | 清空规则链                                   |
| -L          | 查看规则链                                   |
| -A          | 在规则链的末尾加入新规则                     |
| -I num      | 在规则链的头部加入新规则                     |
| -D num      | 删除某一条规则                               |
| -s          | 匹配来源地址IP/MASK，加叹号“!”表示除这个IP外 |
| -d          | 匹配目标地址                                 |
| -i 网卡名称 | 匹配从这块网卡流入的数据                     |
| -o 网卡名称 | 匹配从这块网卡流出的数据                     |
| -p          | 匹配协议，如TCP、UDP、ICMP                   |
| --dport num | 匹配目标端口号                               |
| --sport num | 匹配来源端口号                               |

**1．在iptables命令后添加-L参数查看已有的防火墙规则链。**

```
[root@linuxprobe ~]# iptables -L
```

**2．在iptables命令后添加-F参数清空已有的防火墙规则链。**

```
[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# iptables -L
```

**3．把INPUT规则链的默认策略设置为拒绝。**

```
[root@linuxprobe ~]# iptables -P INPUT DROP
[root@linuxprobe ~]# iptables -L
```

**规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。**

**4．向INPUT链中添加允许ICMP流量进入的策略规则。**

```
[root@linuxprobe ~]# iptables -I INPUT -p icmp -j ACCEPT
```

**5．删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量），并把默认策略设置为允许。**

使用-F参数会清空已有的所有防火墙策略；使用-D参数可以删除某一条指定的策略，因此更加安全和准确。

```
[root@linuxprobe ~]# iptables -D INPUT 1
[root@linuxprobe ~]# iptables -P INPUT ACCEPT
[root@linuxprobe ~]# iptables -L
```

**6．将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量。**

要对某台主机进行匹配，可直接写出它的IP地址；如需对网段进行匹配，则需要写为子网掩码的形式（比如192.168.10.0/24）。

```
[root@linuxprobe ~]# iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT
[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT
```

**7．向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则。**

```
[root@linuxprobe ~]# iptables -I INPUT -p tcp --dport 12345 -j REJECT
[root@linuxprobe ~]# iptables -I INPUT -p udp --dport 12345 -j REJECT
[root@linuxprobe ~]# iptables -L
```

**8．向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则。**

```
[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT
```

**9．向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则。**

前面在添加防火墙策略时，使用的是-I参数，它默认会把规则添加到最上面的位置，因此优先级是最高的。如果工作中需要添加一条最后“兜底”的规则，那就用-A参数吧。这两个参数的效果差别还是很大的：

```
[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT
[root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT
[root@linuxprobe ~]# iptables -L
```

，使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行保存命令：

```
[root@linuxprobe ~]# iptables-save 
```

如果公司服务器是5/6/7版本的话，对应的保存命令应该是：

```
[root@linuxprobe ~]# service iptables save
```

#### Firewalld

默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。

相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。

表8-2                   firewalld中常用的区域名称及策略规则

| 区域     | 默认规则策略                                                 |
| -------- | ------------------------------------------------------------ |
| trusted  | 允许所有的数据包                                             |
| home     | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量 |
| internal | 等同于home区域                                               |
| work     | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量 |
| public   | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量 |
| external | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量 |
| dmz      | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量 |
| block    | 拒绝流入的流量，除非与流出的流量相关                         |
| drop     | 拒绝流入的流量，除非与流出的流量相关                         |

#### Firwalld命令行终端

firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的。用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表8-3中所示的长格式参数

表8-3                  firewall-cmd命令中使用的参数以及作用

| 参数                          | 作用                                                 |
| ----------------------------- | ---------------------------------------------------- |
| --get-default-zone            | 查询默认的区域名称                                   |
| --set-default-zone=<区域名称> | 设置默认的区域，使其永久生效                         |
| --get-zones                   | 显示可用的区域                                       |
| --get-services                | 显示预先定义的服务                                   |
| --get-active-zones            | 显示当前正在使用的区域与网卡名称                     |
| --add-source=                 | 将源自此IP或子网的流量导向指定的区域                 |
| --remove-source=              | 不再将源自此IP或子网的流量导向某个指定区域           |
| --add-interface=<网卡名称>    | 将源自该网卡的所有流量都导向某个指定区域             |
| --change-interface=<网卡名称> | 将某个网卡与区域进行关联                             |
| --list-all                    | 显示当前区域的网卡配置参数、资源、端口以及服务等信息 |
| --list-all-zones              | 显示所有区域的网卡配置参数、资源、端口以及服务等信息 |
| --add-service=<服务名>        | 设置默认区域允许该服务的流量                         |
| --add-port=<端口号/协议>      | 设置默认区域允许该端口的流量                         |
| --remove-service=<服务名>     | 设置默认区域不再允许该服务的流量                     |
| --remove-port=<端口号/协议>   | 设置默认区域不再允许该端口的流量                     |
| --reload                      | 让“永久生效”的配置规则立即生效，并覆盖当前的配置规则 |
| --panic-on                    | 开启应急状况模式                                     |
| --panic-off                   | 关闭应急状况模式                                     |

~~~
Runtime：当前立即生效，重启后失效。

Permanent：当前不生效，重启后生效。

~~~

1．查看firewalld服务当前所使用的区域。

这是一步非常重要的操作。在配置防火墙策略前，必须查看当前生效的是哪个区域，否则配置的防火墙策略将不会立即生效。

~~~
[root@linuxprobe ~]# firewall-cmd --get-default-zone
public
~~~

2．查询指定网卡在firewalld服务中绑定的区域。

```
[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=ens160
```

3．把网卡默认区域修改为external，并在系统重启后生效。

~~~
[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=ens160
~~~

4．把firewalld服务的默认区域设置为public。

默认区域也叫全局配置，指的是对所有网卡都生效的配置，优先级较低。

~~~
[root@linuxprobe ~]# firewall-cmd --set-default-zone=public
~~~

5．启动和关闭firewalld防火墙服务的应急状况模式。

阻断一切网络连接，使用--panic-on参数会立即切断一切网络连接，而使用--panic-off则会恢复网络连接。切记，紧急模式会切断一切网络连接，因此在远程管理服务器时，在按下回车键前一定要三思。

~~~
[root@linuxprobe ~]# firewall-cmd --panic-on
success
[root@linuxprobe ~]# firewall-cmd --panic-off
success
~~~

6．查询SSH和HTTPS协议的流量是否允许放行。

在工作中可以不使用--zone参数指定区域名称，firewall-cmd命令会自动依据默认区域进行查询，从而减少用户输入量。但是，如果默认区域与网卡所绑定的不一致时，就会发生冲突，因此规范写法的zone参数是一定要加的。

```
[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=ssh
yes
[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https
no
```

7．把HTTPS协议的流量设置为永久允许放行，并立即生效。

默认情况下进行的修改都属于Runtime模式，即当前生效而重启后失效，因此在工作和考试中尽量避免使用。而在使用--permanent参数时，则是当前不会立即看到效果，而在重启或重新加载后方可生效。于是，在添加了允许放行HTTPS流量的策略后，查询当前模式策略，发现依然是不允许放行HTTPS协议的流量：

```
[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=https
success
[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https
no
```

不想重启服务器的话，就用--reload参数吧：

```
[root@linuxprobe ~]# firewall-cmd --reload
success
[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https
yes
```

8．把HTTP协议的流量设置为永久拒绝，并立即生效。

由于在默认情况下HTTP协议的流量就没有被允许，所以会有“Warning: NOT_ENABLED: http”这样的提示信息，因此对实际操作没有影响。

```
[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http
Warning: NOT_ENABLED: http
success
[root@linuxprobe ~]# firewall-cmd --reload 
success
```

9．把访问8080和8081端口的流量策略设置为允许，但仅限当前生效。

```
[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcp
success
[root@linuxprobe ~]# firewall-cmd --zone=public --list-ports
8080-8081/tcp
```

10．把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效。

SSH远程控制协议是基于TCP/22端口传输控制指令的，如果想让用户通过其他端口号也能访问ssh服务，就可以试试端口转发技术了。通过这项技术，新的端口号在收到用户请求后会自动转发到原本服务的端口上，使得用户能够通过新的端口访问到原本的服务。

使用firewall-cmd命令实现端口转发的格式有点长，这里为大家总结好了：

> firewall-cmd --permanent --zone=**<区域>** --add-forward-port=port=<源端口号>:proto=**<协议>**:toport=**<目标端口号>**:toaddr=**<目标IP地址>**

目标IP地址一般是服务器本机的IP地址：

```
[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10
success
[root@linuxprobe ~]# firewall-cmd --reload
success
```

#### 服务的访问控制列表

Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrapper服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。

TCP Wrapper服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则会进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件都没有匹配到，则默认放行流量。

由于RHEL 8版本已经不再支持TCP Wrapper服务程序，因此我们接下来选择在一台老版本的服务器上进行实验。TCP Wrapper服务的控制列表文件配置起来并不复杂，常用的参数如表8-4所示。

表8-4              TCP Wrappers服务的控制列表文件中常用的参数

| 客户端类型     | 示例                       | 满足示例的客户端列表               |
| -------------- | -------------------------- | ---------------------------------- |
| 单一主机       | 192.168.10.10              | IP地址为192.168.10.10的主机        |
| 指定网段       | 192.168.10.                | IP段为192.168.10.0/24的主机        |
| 指定网段       | 192.168.10.0/255.255.255.0 | IP段为192.168.10.0/24的主机        |
| 指定DNS后缀    | .linuxprobe.com            | 所有DNS后缀为.linuxprobe.com的主机 |
| 指定主机名称   | www.linuxprobe.com         | 主机名称为www.linuxprobe.com的主机 |
| 指定所有客户端 | ALL                        | 所有主机全部包括在内               |



在配置TCP Wrapper服务时需要遵循两个原则：

> 编写拒绝策略规则时，填写的是服务名称，而非协议名称；
>
> 建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。

#### Cockpit驾驶舱管理工具

