## linux

[toc]

**Linux系统中的一切都是文件**

### 环境安装

#### vmware
### 安装软件
RPM （红帽软件包管理器）

##### 常用的RPM软件包命令

rpm -ivh filename.rpm| 安装软件
:--------|----------
 rpm -e filename.rpm | 卸载软件
 rpm -qpi filename.rpm| 查询软件描述信息
 rpm -qpl filename.rpm |列出软件文件信息
 rpm -qf filename|查询文件属于哪个RPM
##### Yum软件仓库

Yum软件仓库便是为了进一步降低软件安装难度和复杂度而设计的技术。Yum软件仓库可以根据用户的要求分析出所需软件包及其相关的依赖关系，然后自动从服务器下载软件包并安装到系统。

##### 存在问题

分析不准确、内存占用量大、不能多人同时安装软件等硬伤

##### 更好的解决方式-DNF

DNF特别友好地继承了原有的命令格式，且使用习惯上也保持了一致。大家不用担心不会操作，我们来看一个例子。以前，安装软件用的命令是“yum install软件包名称”，那么现在则是“dnf install软件包名称”（也就是说，将yum替换成dnf即可）。

### 系统初始化进程

Linux系统的开机过程是这样的，即先从BIOS开始，然后进入Boot Loader，再加载系统内核，然后内核进行初始化，最后启动初始化进程。初始化进程作为Linux系统启动后的第一个正式服务，它需要完成Linux系统中相关的初始化工作，为用户提供合适的工作环境。同学们可以将初始化进程粗犷地理解成从我们按下开机键到看见系统桌面的这个过程。初始化进程完成了一大半工作。
红帽RHEL 7/8系统替换掉了熟悉的初始化进程服务System V init，正式采用全新的systemd初始化进程服务。

![img](file:///C:\Users\Xlibi\AppData\Roaming\Tencent\Users\1046135549\TIM\WinTemp\RichOle\BEZ[IB6{NJWWY7$$XDBF~L9.png)

![img](file:///C:\Users\Xlibi\AppData\Roaming\Tencent\Users\1046135549\TIM\WinTemp\RichOle\A2[[OSFIARHI646_7FG1YP0.png)

### shell命令

Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。
人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg)

Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器。

4项优势：

~~~text
通过上下方向键来调取执行过的Linux命令；

命令或参数仅需输入前几位就可以用Tab键补全；

具有强大的批处理[脚本](https://www.linuxcool.com/)；

具有实用的环境变量功能。
~~~

#### 常见的执行Linux命令的格式

~~~text
命令名称     [命令参数]     [命令对象]
~~~

**命令名称**：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。

**命令参数**：用于对命令进行调整，参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“--”与“-”作为前缀。

**命令对象**：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。

*注意：命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。*

man命令自身的帮助信息----manman

表2-2                      man命令中常用按键以及作用

| 按键      | 作用                               |
| --------- | ---------------------------------- |
| 空格键    | 向下翻一页                         |
| PaGe down | 向下翻一页                         |
| PaGe up   | 向上翻一页                         |
| home      | 直接前往首页                       |
| end       | 直接前往尾页                       |
| /         | 从上至下搜索某个关键词，如“/linux” |
| ?         | 从下至上搜索某个关键词，如“?linux” |
| n         | 定位到下一个搜索到的关键词         |
| N         | 定位到上一个搜索到的关键词         |
| q         | 退出帮助文档                       |

表2-3                     man命令中帮助信息的结构以及意义

| 结构名称    | 代表意义                 |
| ----------- | ------------------------ |
| NAME        | 命令的名称               |
| SYNOPSIS    | 参数的大致使用方法       |
| DESCRIPTION | 介绍说明                 |
| EXAMPLES    | 演示（附带简单说明）     |
| OVERVIEW    | 概述                     |
| DEFAULTS    | 默认的功能               |
| OPTIONS     | 具体的可用选项（带介绍） |
| ENVIRONMENT | 环境变量                 |
| FILES       | 用到的文件               |
| SEE ALSO    | 相关的资料               |
| HISTORY     | 维护历史与联系方式       |

[root@linuxprobe～]#这部分内容是**终端提示符**

展示一些基本的信息—当前登录用户名为root，简要的主机名是linuxprobe，所在目录是～

\#表示管理员身份（如果是$则表示普通用户，相应的权限也会小一些）。

**Tab键：实现对命令、参数或文件的内容补全。**

**Ctrl+c组合键**：当同时按下键盘上的Ctrl和字母c的时候，意味着终止当前进程的运行。

**Ctrl+d组合键**：当同时按下键盘上的Ctrl和字母d的时候，表示键盘输入结束。

**Ctrl+l组合键**：当同时按下键盘上的Ctrl和字母l的时候，会清空当前终端中已有的内容（相当于清屏操作）。

#### 常用系统工作命令

##### echo命令

语法格式为“echo [字符串] [$变量]”，在终端设备上输出字符串或变量提取后的值。

例如，把指定字符串“LinuxProbe.com”输出到终端屏幕的命令为：

```
[root@linuxprobe ~]# echo LinuxProbe.com
```

该命令会在终端屏幕上显示如下信息：

```
LinuxProbe.com
```

下面使用“$变量”的方式提取出变量SHELL的值，并将其输出到屏幕上：

```
[root@linuxprobe ~]# echo $SHELL
/bin/bash
```

##### date命令

显示或设置系统的时间与日期，语法格式为“date [+指定的格式]”。

表2-4                        date命令中的参数及其作用

| 参数 | 作用                             |
| ---- | -------------------------------- |
| %S   | 秒（00～59）                     |
| %M   | 分钟（00～59）                   |
| %H   | 小时（00～23）                   |
| %I   | 小时（00～12）                   |
| %m   | 月份（1~12）                     |
| %p   | 显示出AM或PM                     |
| %a   | 缩写的工作日名称（例如：Sun）    |
| %A   | 完整的工作日名称（例如：Sunday） |
| %b   | 缩写的月份名称（例如：Jan）      |
| %B   | 完整的月份名称（例如：January）  |
| %q   | 季度（1~4）                      |
| %y   | 简写年份（例如：20）             |
| %Y   | 完整年份（例如：2020）           |
| %d   | 本月中的第几天                   |
| %j   | 今年中的第几天                   |
| %n   | 换行符（相当于按下回车键）       |
| %t   | 跳格（相当于按下Tab键）          |

按照默认格式查看当前系统时间的date命令如下所示：

```
[root@linuxprobe ~]# date
Sat Sep 5 09:13:45 CST 2020
```

按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的date命令如下所示：

```
[root@linuxprobe ~]# date "+%Y-%m-%d %H:%M:%S"
2020-09-05 09:14:35
```

将系统的当前时间设置为2020年11月1日8点30分的date命令如下所示：

```
[root@linuxprobe ~]# date -s "20201101 8:30:00"
Sun Nov 1 08:30:00 CST 2020
```

##### timedatectl命令

设置系统的时间，英文全称为“time date control”，语法格式为“timedatectl [参数]”。

表2-5                        timedatectl命令中的参数以及作用

| 参数           | 作用         |
| -------------- | ------------ |
| status         | 显示状态信息 |
| list-timezones | 列出已知时区 |
| set-time       | 设置系统时间 |
| set-timezone   | 设置生效时区 |

如果您查到的时区不是上海（Asia/Shanghai），可以手动进行设置：

```
[root@linuxprobe ~]# timedatectl set-timezone Asia/Shanghai
```

如果时间还是不正确，可再手动修改系统日期：

```
[root@linuxprobe ~]# timedatectl set-time 2021-05-18
```

而如果想修改时间的话，也很简单：

```
[root@linuxprobe ~]# timedatectl set-time 9:30
[root@linuxprobe ~]# date 
Tue May 18 09:30:01 CST 2021
```

##### rebot命令

重启系统，输入该命令后按回车键执行即可。

管理员用户操作，普通用户在执行该命令时可能会被拒绝。

##### poweroff命令

关闭系统，输入该命令后按回车键执行。管理员用户操作，普通用户在执行该命令时可能会被拒绝。

##### wget命令

终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。

表2-6                        wget命令中的参数以及作用

| 参数 | 作用                                 |
| ---- | ------------------------------------ |
| -b   | 后台下载模式                         |
| -P   | 下载到指定目录                       |
| -t   | 最大尝试次数                         |
| -c   | 断点续传                             |
| -p   | 下载页面内所有资源，包括图片、视频等 |
| -r   | 递归下载                             |

##### ps命令

查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。

ps命令与管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。ps命令的常见参数以及作用如表2-7所示。

表2-7                         ps命令中的参数以及作用

| 参数 | 作用                               |
| ---- | ---------------------------------- |
| -a   | 显示所有进程（包括其他用户的进程） |
| -u   | 用户以及其他详细信息               |
| -x   | 显示没有控制终端的进程             |

Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。

~~~text
R（运行）：进程正在运行或在运行队列中等待。
S（中断）：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该   状态。
D（不可中断）：进程不响应系统异步信号，即便用kill命令也不能将其中断。
Z（僵死）：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。
T（停止）：进程收到停止信号后停止运行。
~~~

除了上面5种常见的进程状态，还有可能是高优先级（<）、低优先级（N）、被锁进内存（L）、包含子进程（s）以及多线程（l）这5种补充形式。

当执行ps aux命令后通常会看到如表2-8所示的进程状态。表2-8只是列举了部分输出值，而且正常的输出值中不包括中文注释。

当执行ps aux命令后通常会看到如表2-8所示的进程状态。表2-8只是列举了部分输出值，而且正常的输出值中不包括中文注释。

表2-8                              进程状态

| USER         | PID      | %CPU         | %MEM       | VSZ                      | RSS                        | TTY      | STAT     | START        | TIME              | COMMAND                                                      |
| ------------ | -------- | ------------ | ---------- | ------------------------ | -------------------------- | -------- | -------- | ------------ | ----------------- | ------------------------------------------------------------ |
| 进程的所有者 | 进程ID号 | 运算器占用率 | 内存占用率 | 虚拟内存使用量(单位是KB) | 占用的固定内存量(单位是KB) | 所在终端 | 进程状态 | 被启动的时间 | 实际使用CPU的时间 | 命令名称与参数                                               |
| root         | 1        | 0.0          | 0.5        | 244740                   | 10636                      | ?        | Ss       | 07:54        | 0:02              | /usr/lib/systemd/ systemd --switched-root --system --deserialize 18 |
| root         | 2        | 0.0          | 0.0        | 0                        | 0                          | ?        | S        | 07:54        | 0:00              | [kthreadd]                                                   |
| root         | 3        | 0.0          | 0.0        | 0                        | 0                          | ?        | I<       | 07:54        | 0:00              | [rcu_gp]                                                     |
| root         | 4        | 0.0          | 0.0        | 0                        | 0                          | ?        | I<       | 07:54        | 0:00              | [rcu_par_gp]                                                 |

*在Linux系统中的命令参数有长短格式之分，长格式和长格式之间不能合并，长格式和短格式之间也不能合并，但短格式和短格式之间是可以合并的，合并后仅保留一个减号（-）即可。另外ps命令可允许参数不加减号（-），因此可直接写成ps aux的样子。*

##### pstree命令

以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。

##### top命令

动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。动态地查看系统状态。

##### nice命令

调整进程的优先级，语法格式为“nice优先级数字 服务名称”。

在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。例如将bash服务的优先级调整到最高：

```
[root@linuxprobe ~]# nice -n -20 bash
[root@linuxprobe ~]#
```

##### pidof命令

查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。

每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。例如，执行如下命令来查询本机上sshd服务程序的PID：

```
[root@linuxprobe ~]# pidof sshd
2156
```

##### kill命令

终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。

但有时系统会提示进程无法被终止，此时可以加参数-9，表示最高级别地强制杀死进程：

```
[root@linuxprobe ~]# kill -9 2156
```

##### killall命令

终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。

如果在系统终端中执行一个命令后想立即停止它，可以同时按下Ctrl + C组合键（生产环境中比较常用的一个组合键），这样将立即终止该命令的进程。或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾添加一个&符号，这样命令将进入系统后台来执行。

#### 系统状态检测命令

##### ifconfig命令

获取网卡配置与网络状态等信息，英文全称为“interface config”，语法格式为“ifconfig [参数] [网络设备]”。

##### uname命令

查看系统内核版本与系统架构等信息，英文全称为“unix name”，语法格式为“uname [-a]”。

在使用uname命令时，一般要固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、压制时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息

##### uptime命令

查看系统的负载信息，输入该命令后按回车键执行即可。

uptime命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分），负载值越低越好：

```
[root@linuxprobe ~]# uptime
22:49:55 up 10 min, 1 users, load average: 0.01, 0.19, 0.18
```

##### free命令

显示当前系统中内存的使用量信息，语法格式为“free [-h]”。

使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息

```
[root@linuxprobe ~]# free -h
```

表2-9                      执行free -h命令后的输出信息

|       | 内存总量 | 已用量 | 空闲量 | 进程共享的内存量 | 磁盘缓存的内存量 | 缓存的内存量 | 可用量    |
| ----- | -------- | ------ | ------ | ---------------- | ---------------- | ------------ | --------- |
|       | total    | used   | free   | shared           | buffers          | buff/cache   | available |
| Mem:  | 1.9Gi    | 1.4Gi  | 99Mi   | 20Mi             | 450Mi            | 348Mi        |           |
| Swap: | 2.0Gi    | 80Mi   | 1.9Gi  |                  |                  |              |           |



如果不使用-h（易读模式）查看内存使用量情况，则默认以KB为单位。这样一来，服务器如果有几百GB的内存，则换算下来就会是一大长串的数字，真不利于阅读。

##### who命令

查看当前登入主机的用户终端信息，输入该命令后按回车键执行即可。

这3个简单的字母可以快速显示出所有正在登录本机的用户名称以及他们正在开启的终端信息；如果有远程用户，还会显示出来访者的IP地址。表2-10所示为执行who命令后的结果。

```
[root@linuxprobe ~]# who
```

表2-10                     执行who命令的结果

| 登陆的用户名 | 终端设备 | 登陆到系统的时间        |
| ------------ | -------- | ----------------------- |
| root         | tty2     | 2020-07-24 06:26 (tty2) |

##### last命令

调取主机的被访记录，输入该命令后按回车键执行即可。

##### ping命令

测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。

表2-11                         ping命令中的参数以及作用

| 参数 | 作用               |
| ---- | ------------------ |
| -c   | 总共发送次数       |
| -l   | 指定网卡名称       |
| -i   | 每次间隔时间（秒） |
| -W   | 最长等待时间（秒） |

##### tracepath命令

显示数据包到达目的主机时途中经过的所有路由信息，语法格式为“tracepath [参数] 域名”。

当两台主机之间无法正常ping通时，要考虑两台主机之间是否有错误的路由信息，导致数据被某一台设备错误地丢弃。这时便可以使用tracepath命令追踪数据包到达目的主机时途中的所有路由信息，以分析是哪台设备出了问题。

##### netstat命令

netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。

表2-12                         netstat命令中的参数以及作用

| -a   | 显示所有连接中的Socket   |
| ---- | ------------------------ |
| -p   | 显示正在使用的Socket信息 |
| -t   | 显示TCP协议的连接状态    |
| -u   | 显示UDP协议的连接状态    |
| -n   | 使用IP地址，不使用域名   |
| -l   | 仅列出正在监听的服务状态 |
| -i   | 显示网卡列表信息         |
| -r   | 显示路由表信息           |

##### history命令

显示执行过的命令历史，语法格式为“history [-c]”。使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。

##### sosreport命令

收集系统配置及架构信息并输出诊断文档，输入该命令后按回车键执行即可。

#### 查找文件定位命令

##### pwd命令

显示用户当前所处的工作目录，英文全称为“print working directory”，输入该命令后按回车键执行即可。

##### cd命令

切换当前的工作路径，英文全称为“change directory”，语法格式为“cd [参数] [目录]”。“cd -”命令返回到上一次所处的目录，使用“cd..”命令进入上级目录，以及使用“cd～”命令切换到当前用户的家目录，抑或使用“cd～username”命令切换到其他用户的家目录

##### ls命令

显示目录中的文件信息，英文全称为“list”，语法格式为“ls [参数] [文件名称]”。

ls命令的-a参数可以看到全部文件（包括隐藏文件），使用-l参数可以查看文件的属性、大小等详细信息。将这两个参数整合之后，再执行ls命令即可查看当前目录中的所有文件并输出这些文件的属性信息

要查看目录属性信息，则需要额外添加一个-d参数

##### tree命令

以树状图的形式列出目录内容及结构，输入该命令后按回车键执行即可。

##### find命令

按照指定条件来查找文件所对应的位置，语法格式为“find [查找范围] 寻找条件”。

表2-13                       find命令中的参数以及作用

| 参数              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| -name             | 匹配名称                                                     |
| -perm             | 匹配权限（mode为完全匹配，-mode为包含即可）                  |
| -user             | 匹配所有者                                                   |
| -group            | 匹配所有组                                                   |
| -mtime -n +n      | 匹配修改内容的时间（-n指n天以内，+n指n天以前）               |
| -atime -n +n      | 匹配访问文件的时间（-n指n天以内，+n指n天以前）               |
| -ctime -n +n      | 匹配修改文件权限的时间（-n指n天以内，+n指n天以前）           |
| -nouser           | 匹配无所有者的文件                                           |
| -nogroup          | 匹配无所有组的文件                                           |
| -newer f1 !f2     | 匹配比文件f1新但比f2旧的文件                                 |
| -type b/d/c/p/l/f | 匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件） |
| -size             | 匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件） |
| -prune            | 忽略某个目录                                                 |
| -exec …… {}\;     | 后面可跟用于进一步处理搜索结果的命令（下文会有演示）         |

如果要想获取etc目录中所有以host开头的文件列表

```
find /etc -name "host*" -print
```

在整个文件系统中找出所有归属于linuxprobe用户的文件并复制到/root/findresults目录中。
该实验的重点是“-exec {} \;”参数，其中的{}表示find命令搜索出的每一个文件，并且命令的结尾必须是“\;”。完成该实验的具体命令如下：

[root@linuxprobe ~]# find / -user linuxprobe -exec cp -a {} /root/findresults/ \;

##### locate命令

按照名称快速搜索文件所对应的位置，语法格式为“locate文件名称”。

find命令进行全盘搜索虽然更准确，但是效率有点低。如果仅仅是想找一些常见的且又知道大概名称的文件，不如试试locate命令，在使用locate命令时，先使用updatedb命令生成一个索引库文件，这个库文件的名字是/var/lib/mlocate/mlocate.db，后续在使用locate命令搜索文件时就是在该库中进行查找操作，速度会快很多。

第一次使用locate命令之前，记得先执行updatedb命令来生成索引数据库，然后再进行查找：

使用locate命令搜索出所有包含“whereis”名称的文件所在的位置：

##### whereis命令

按照名称快速搜索二进制程序（命令）、源代码以及帮助文件所对应的位置，语法格式为“whereis命令名称”。

简单来说，whereis命令也是基于updatedb命令所生成的索引库文件进行搜索，它与locate命令的区别是不关心那些相同名称的文件，仅仅是快速找到对应的命令文件及其帮助文件所在的位置。

##### which命令

按照指定名称快速搜索二进制程序（命令）所对应的位置，语法格式为“which命令名称”。

hich命令是在PATH变量所指定的路径中，按照指定条件搜索命令所在的路径。也就是说，如果我们既不关心同名文件（find与locate），也不关心命令所对应的源代码和帮助文件（whereis），仅仅是想找到命令本身所在的路径，那么这个which命令就太合适了。

#### 文本文件编辑命令

##### cat命令

用于查看纯文本文件（内容较少的），英文全称为“concatenate”，语法格式为“cat [参数] 文件名称”。

查看文本内容时还想顺便显示行号的话，不妨在cat命令后面追加一个-n参数

##### more命令

查看纯文本文件（内容较多的），语法格式为“more [参数] 文件名称”。使用空格键或回车键向下翻页

##### head命令

查看纯文本文件的前*N*行，语法格式为“head [参数] 文件名称”。

查看前十行

```
head -n 10 ks.cfg
```

##### tail命令

查看纯文本文件的后*N*行或持续刷新文件的最新内容，语法格式为“tail [参数] 文件名称”。

比如需要查看文本内容的最后10行，tail命令的操作方法与head命令非常相似，只需要执行“tail -n 20文件名称”

持续刷新一个文件的内容，命令格式为“tail -f文件名称”

##### tr命令

替换文本内容中的字符，英文全称为“transform”，语法格式为“tr [原始字符] [目标字符]”。

快速地替换文本中的一些词汇,先使用cat命令读取待处理的文本，然后通过管道符把这些文本内容传递给tr命令进行替换操作即可

##### wc命令

统计指定文本文件的行数、字数或字节数，英文全称为“word counts”，语法格式为“wc [参数] 文件名称”。

表2-14                          wc命令中的参数以及作用

| 参数 | 作用         |
| ---- | ------------ |
| -l   | 只显示行数   |
| -w   | 只显示单词数 |
| -c   | 只显示字节数 |

##### stat命令

查看文件的具体存储细节和时间等信息，英文全称为“status”，语法格式为“stat文件名称”。

Linux系统中的文件包含3种时间状态，分别是Access Time（内容最后一次被访问的时间，简称为Atime），Modify Time（内容最后一次被修改的时间，简称为Mtime）以及Change Time（文件属性最后一次被修改的时间，简称为Ctime）。

##### grep命令

按行提取文本内容，语法格式为“grep [参数] 文件名称”。

~~~text
-n参数用来显示搜索到的信息的行号；

-v参数用于反选信息（即没有包含关键词的所有信息行）。
~~~

表2-15                       grep命令中的参数及其作用

| 参数 | 作用                                           |
| ---- | ---------------------------------------------- |
| -b   | 将可执行文件(binary)当作文本文件（text）来搜索 |
| -c   | 仅显示找到的行数                               |
| -i   | 忽略大小写                                     |
| -n   | 显示行号                                       |
| -v   | 反向选择——仅列出没有“关键词”的行。             |

##### cut命令

按“列”提取文本内容，语法格式为“cut [参数] 文件名称”。

使用-d参数来设置间隔符号。-f参数设置需要查看的列数，

```
cut -d : -f 1 /etc/passwd
```

##### diff命令

比较多个文件之间内容的差异，英文全称为“different”，语法格式为“diff [参数] 文件名称A 文件名称B”。

使用--brief参数来确认两个文件是否相同，还可以使用-c参数来详细比较出多个文件的差异之处

##### uniq命令

去除文本中连续的重复行，英文全称为“unique”，语法格式为“uniq [参数] 文件名称”。

##### sort命令

对文本内容进行再排序，语法格式为“sort [参数] 文件名称”。

表2-16                       sort命令中的参数及其作用

| 参数 | 作用           |
| ---- | -------------- |
| -f   | 忽略大小写     |
| -b   | 忽略缩进与空格 |
| -n   | 以数值型排序   |
| -r   | 反向排序       |
| -u   | 去除重复行     |
| -t   | 指定间隔符     |
| -k   | 设置字段范围   |

#### 文件目录管理命令

##### touch命令

创建空白文件或设置文件的时间，语法格式为“touch [参数] 文件名称”。

表2-17                       touch命令中的参数及其作用

| 参数 | 作用                      |
| ---- | ------------------------- |
| -a   | 仅修改“读取时间”（atime） |
| -m   | 仅修改“修改时间”（mtime） |
| -d   | 同时修改atime与mtime      |

```
touch -d "2020-05-04 15:44" anaconda-ks.cfg 
```

##### mkdir命令

创建空白的目录，英文全称为“make directory”，语法格式为“mkdir [参数] 目录名称”。

-p参数来递归创建出具有嵌套层叠关系的文件目录

```
mkdir -p a/b/c/d/e
```

##### cp命令

复制文件或目录，英文全称为“copy”，语法格式为“cp [参数] 源文件名称 目标文件名称”。

~~~
如果目标文件是目录，则会把源文件复制到该目录中；

如果目标文件也是普通文件，则会询问是否要覆盖它；

如果目标文件不存在，则执行正常的复制操作。
~~~

复制命令基本不会出错，唯一需要记住的就是在复制目录时要加上-r参数。cp命令的参数及其作用如表2-18所示。

表2-18                        cp命令中的参数及其作用

| 参数 | 作用                                         |
| ---- | -------------------------------------------- |
| -p   | 保留原始文件的属性                           |
| -d   | 若对象为“链接文件”，则保留该“链接文件”的属性 |
| -r   | 递归持续复制（用于目录）                     |
| -i   | 若目标文件存在则询问是否覆盖                 |
| -a   | 相当于-pdr（p、d、r为上述参数）              |

##### mv命令

剪切或重命名文件，英文全称为“move”，语法格式为“mv [参数] 源文件名称 目标文件名称”。

##### rm命令

删除文件或目录，英文全称为“remove”，语法格式为“rm [参数] 文件  名称”。

系统会默认向您询问是否要执行删除操作，如果不想总是看到这种反复的确认信息，可在rm命令后跟上-f参数来强制删除。另外，要想删除一个目录，需要在rm命令后面加一个-r参数才可以，否则删除不掉。rm命令的参数及其作用如表2-19所示。

表2-19                        rm命令中的参数及其作用

| 参数 | 作用       |
| ---- | ---------- |
| -f   | 强制执行   |
| -i   | 删除前询问 |
| -r   | 删除目录   |
| -v   | 显示过程   |

##### dd命令

按照指定大小和个数的数据块来复制文件或转换文件，语法格式为“dd if=参数值of=参数值count=参数值bs=参数值”。

它能够让用户按照指定大小和个数的数据块来复制文件的内容。还可以在复制过程中转换其中的数据。Linux系统中有一个名为/dev/zero的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此常常使用它作为dd命令的输入文件，来生成一个指定大小的文件。dd命令的参数及其作用如表2-20所示。

表2-20                        dd命令中的参数及其作用

| 参数  | 作用                 |
| ----- | -------------------- |
| if    | 输入的文件名称       |
| of    | 输出的文件名称       |
| bs    | 设置每个“块”的大小   |
| count | 设置要复制“块”的个数 |

用dd命令从/dev/zero设备文件中取出一个大小为560MB的数据块，然后保存成名为560_file的文件

```
dd if=/dev/zero of=560_file count=1 bs=560M
```

##### file命令

查看文件的类型，语法格式为“file文件名称”。

##### tar命令

对文件进行打包压缩或解压，语法格式为“tar参数 文件名称”。

表2-21                        tar命令中的参数及其作用

| 参数 | 作用                   |
| ---- | ---------------------- |
| -c   | 创建压缩文件           |
| -x   | 解开压缩文件           |
| -t   | 查看压缩包内有哪些文件 |
| -z   | 用Gzip压缩或解压       |
| -j   | 用bzip2压缩或解压      |
| -v   | 显示压缩或解压的过程   |
| -f   | 目标文件名             |
| -p   | 保留原始的权限与属性   |
| -P   | 使用绝对路径来压缩     |
| -C   | 指定解压到的目录       |

一般使用“tar -czvf压缩包名称.tar.gz要打包的目录”命令把指定的文件进行打包压缩；相应的解压命令为“tar -xzvf压缩包名称.tar.gz”。

### 重定向

#### 输入输出重定向

输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。

使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。

~~~text、
标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入。

标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕。

错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕。
~~~

对于输入重定向来讲，用到的符号及其作用如表3-1所示。

表3-1                     输入重定向中用到的符号及其作用

| 符号                 | 作用                                         |
| -------------------- | -------------------------------------------- |
| 命令 < 文件          | 将文件作为命令的标准输入                     |
| 命令 << 分界符       | 从标准输入中读入，直到遇见分界符才停止       |
| 命令 < 文件1 > 文件2 | 将文件1作为命令的标准输入并将标准输出到文件2 |



对于输出重定向来讲，用到的符号及其作用如表3-2所示。

表3-2                     输出重定向中用到的符号及其作用

| 符号                               | 作用                                                 |
| ---------------------------------- | ---------------------------------------------------- |
| 命令 > 文件                        | 将标准输出重定向到一个文件中（清空原有文件的数据）   |
| 命令 2> 文件                       | 将错误输出重定向到一个文件中（清空原有文件的数据）   |
| 命令 >> 文件                       | 将标准输出重定向到一个文件中（追加到原有内容的后面） |
| 命令 2>> 文件                      | 将错误输出重定向到一个文件中（追加到原有内容的后面） |
| 命令 >> 文件 2>&1 或 命令 &>> 文件 | 将标准输出与错误输出共同写                           |

命令的报错信息写入到文件使用错误输出重定向。

使用输入重定向把readme.txt文件导入给wc -l命令，统计一下文件中的内容行数：

```
[root@linuxprobe ~]# wc -l < readme.txt
2
```

### 管道命令符

同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。

“**把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入**”

我们完全可以这样使用：“命令A | 命令B | 命令C”

### 命令行的通配符

通配符就是通用的匹配信息的符号，

星号（*）代表匹配零个或多个字符，问号（?）代表匹配单个字符，中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符，而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符。Linux系统中的通配符及含义如表3-3所示。

表3-3                    Linux系统中的通配符及含义

| 通配符      | 含义           |
| ----------- | -------------- |
| *           | 任意字符       |
| ?           | 单个任意字符   |
| [a-z]       | 单个小写字母   |
| [A-Z]       | 单个大写字母   |
| [a-Z]       | 单个字母       |
| [0-9]       | 单个数字       |
| [[:alpha:]] | 任意字母       |
| [[:upper:]] | 任意大写字母   |
| [[:lower:]] | 任意小写字母   |
| [[:digit:]] | 所有数字       |
| [[:alnum:]] | 任意字母加数字 |
| [[:punct:]] | 标点符号       |

### 常用的转义字符

~~~text
反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符。

单引号（' '）：转义其中所有的变量为单纯的字符串。

双引号（" "）：保留其中的变量属性，不进行转义处理。

反引号（` `）：把其中的命令执行后返回结果。
~~~

如果参数中出现了空格，就加双引号；如果参数中没有空格，那就不用加双引号。

### 重要的环境变量

在Linux系统中，变量名称一般都是大写的，命令则都是小写的，这是一种约定俗成的规范。

命令在Linux中的执行分为4个步骤。

**第1步**：判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是绝对路径则直接执行，否则进入第2步继续判断。

**第2步**：Linux系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令名称来替换原本的命令名称。

**第3步**：Bash解释器判断用户输入的是内部命令还是外部命令。内部命令是解释器内部的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤4继续处理。可以使用“type命令名称”来判断用户输入的命令是内部命令还是外部命令

**第4步**：系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作PATH，可以简单地把它理解成是“解释器的小助手”，作用是告诉Bash解释器待执行的命令可能存放的位置，然后Bash解释器就会乖乖地在这些位置中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用冒号间隔，对这些路径的增加和删除操作将影响到Bash解释器对Linux命令的查找。

使用env命令来查看Linux系统中所有的环境变量

表3-4                    Linux系统中最重要的10个环境变量

| 变量名称     | 作用                             |
| ------------ | -------------------------------- |
| HOME         | 用户的主目录（即家目录）         |
| SHELL        | 用户在使用的Shell解释器名称      |
| HISTSIZE     | 输出的历史命令记录条数           |
| HISTFILESIZE | 保存的历史命令记录条数           |
| MAIL         | 邮件保存路径                     |
| LANG         | 系统语言、语系名称               |
| RANDOM       | 生成一个随机数字                 |
| PS1          | Bash解释器的提示符               |
| PATH         | 定义解释器搜索用户执行命令的路径 |
| EDITOR       | 用户默认的文本编辑器             |

### Vim文本编辑器

**在Linux系统中一切都是文件，而配置一个服务就是在修改其配置文件的参数**

于Vim编辑器中设置了3种模式—命令模式、末行模式和编辑模式

~~~text
命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。

输入模式：正常的文本录入。

末行模式：保存或退出文档，以及设置编辑环境。
~~~

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/03/vim%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%BC%8F%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2.png)

表4-1                          命令模式中最常用的一些命令

| 命令 | 作用                                               |
| ---- | -------------------------------------------------- |
| dd   | 删除（剪切）光标所在整行                           |
| 5dd  | 删除（剪切）从光标处开始的5行                      |
| yy   | 复制光标所在整行                                   |
| 5yy  | 复制从光标处开始的5行                              |
| n    | 显示搜索命令定位到的下一个字符串                   |
| N    | 显示搜索命令定位到的上一个字符串                   |
| u    | 撤销上一步的操作                                   |
| p    | 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 |

行模式主要用于保存或退出文件，以及设置Vim编辑器的工作环境，还可以让用户执行外部的Linux命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中输入一个冒号就可以了。末行模式中常用的命令如表4-2所示。

表4-2                          末行模式中最常用的一些命令

| 命令          | 作用                                 |
| ------------- | ------------------------------------ |
| :w            | 保存                                 |
| :q            | 退出                                 |
| :q!           | 强制退出（放弃对文档的修改内容）     |
| :wq!          | 强制保存退出                         |
| :set nu       | 显示行号                             |
| :set nonu     | 不显示行号                           |
| :命令         | 执行该命令                           |
| :整数         | 跳转到该行                           |
| :s/one/two    | 将当前光标所在行的第一个one替换成two |
| :s/one/two/g  | 将当前光标所在行的所有one替换成two   |
| :%s/one/two/g | 将全文中的所有one替换成two           |
| ?字符串       | 在文本中从下至上搜索该字符串         |
| /字符串       | 在文本中从上至下搜索该字符串         |

可以分别使用a、i、o三个键从命令模式切换到输入模式，

在编写完之后，要想保存并退出，必须先敲击键盘的Esc键从输入模式返回命令模式

当在末行模式中输入“:wq!”命令时，就意味着强制保存并退出文档。

##### 编写shell脚本

Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。

Shell脚本命令的工作方式有下面两种。

~~~text
交互式（Interactive）：用户每输入一条命令就立即执行。

批处理（Batch）：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。
~~~

例如：

~~~
[root@linuxprobe ~]# vim example.sh
#!/bin/bash 
#For Example BY linuxprobe.com 
pwd 
ls -al
~~~

第一行的脚本声明（#!）用来告诉系统使用哪种Shell解释器来执行该脚本；第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息；第三、四行的可执行语句也就是我们平时执行的Linux命令了

内设了用于接收参数的变量，变量之间使用空格间隔。例如，$0对应的是当前Shell脚本程序的名称，$#对应的是总共有几个参数，$*对应的是所有位置的参数值，$?对应的是显示上一次命令的执行返回值，而$1、$2、$3……则分别对应着第*N*个位置的参数值，如图所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/Shell%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE%E5%8F%98%E9%87%8F.png)

例

~~~
[root@linuxprobe ~]# vim example.sh
#!/bin/bash
echo "当前脚本名称为$0"
echo "总共有$#个参数，分别是$*。"
echo "第1个参数为$1，第5个为$5。"
[root@linuxprobe ~]# bash example.sh one two three four five six
当前脚本名称为example.sh
总共有6个参数，分别是one two three four five six。
第1个参数为one，第5个为five。
~~~

##### 判断用户参数

Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回非零值。条件测试语法的执行格式如图所示。切记，条件表达式两边均应有一个空格。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5%E6%A0%BC%E5%BC%8F.png)

条件测试语句可以分四种

~~~
文件测试语句；

逻辑测试语句；

整数值比较语句；

字符串比较语句。
~~~

文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如表4-3所示。

表4-3                          文件测试所用的参数

| 操作符 | 作用                       |
| ------ | -------------------------- |
| -d     | 测试文件是否为目录类型     |
| -e     | 测试文件是否存在           |
| -f     | 判断是否为一般文件         |
| -r     | 测试当前用户是否有权限读取 |
| -w     | 测试当前用户是否有权限写入 |
| -x     | 测试当前用户是否有权限执行 |

文件测试语句来判断/etc/fstab是否为一个目录类型的文件，然后通过Shell解释器的内设$?变量显示上一条命令执行后的返回值。如果返回值为0，则目录存在；如果返回值为非零的值，则意味着它不是目录，或这个目录不存在：

~~~
[root@linuxprobe ~]# [ -d /etc/fstab ]
[root@linuxprobe ~]# echo $?
1
~~~

**一定要敲两次命令吗？**

逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在Shell终端中逻辑“与”的运算符号是&&，它表示当前面的命令执行成功后才会执行它后面的命令，因此可以用来判断/dev/cdrom文件是否存在，若存在则输出Exist字样。

~~~
[root@linuxprobe ~]# [ -e /dev/cdrom ] && echo "Exist"
Exist
~~~

逻辑“或”，它在Linux系统中的运算符号为||，表示当前面的命令执行失败后才会执行它后面的命令

逻辑语句是“非”，在Linux系统中的运算符号是一个叹号（！），它表示把条件测试中的判断结果取相反值。

~~~
&&是逻辑“与”，只有当前面的语句执行成功的时候才会执行后面的语句。
||是逻辑“或”，只有当前面的语句执行失败的时候才会执行后面的语句。
!是逻辑“非”，代表对逻辑测试结果取反值；之前若为正确则变成错误，若为错误则变成正确。
~~~

整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规范的整数比较运算符来进行操作。

表4-4                         可用的整数比较运算符

| 操作符 | 作用           |
| ------ | -------------- |
| -eq    | 是否等于       |
| -ne    | 是否不等于     |
| -gt    | 是否大于       |
| -lt    | 是否小于       |
| -le    | 是否等于或小于 |
| -ge    | 是否大于或等于 |

字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如表4-5所示。

表4-5                        常见的字符串比较运算符

| 操作符 | 作用                   |
| ------ | ---------------------- |
| =      | 比较字符串内容是否相同 |
| !=     | 比较字符串内容是否不同 |
| -z     | 判断字符串内容是否为空 |

##### 流程控制语句

###### if条件测试

if条件语句的单分支结构由if、then、fi关键词组成

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/%E5%8D%95%E5%88%86%E6%94%AF%E7%9A%84if%E8%AF%AD%E5%8F%A5.png)

if条件语句的双分支结构由if、then、else、fi关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%8F%8C%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-1.png)

if条件语句的多分支结构由if、then、else、elif、fi关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/%E5%A4%9A%E5%88%86%E6%94%AF%E7%9A%84if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5.png)

###### for条件循环语句

for循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理。当要处理的数据有范围时，使用for循环语句。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/for%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png)首先创建用户名称的列表文件users.txt，每个用户名称单独一行

~~~
[root@linuxprobe ~]# vim users.txt
andy
barry
carl
duke
eric
george
~~~

编写Shell脚本addusers.sh。在脚本中使用read命令读取用户输入的密码值，然后赋值给PASSWD变量，并通过-p参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。在执行该脚本后，会自动使用从列表文件users.txt中获取到所有的用户名称，然后逐一使用“id用户名”命令查看用户的信息，并使用$?判断这条命令是否执行成功，也就是判断该用户是否已经存在。

~~~
[root@linuxprobe ~]# vim addusers.sh
#!/bin/bash
read -p "Enter The Users Password : " PASSWD
for UNAME in `cat users.txt`
do
        id $UNAME &> /dev/null
        if [ $? -eq 0 ]
        then
                echo "$UNAME , Already exists"
        else
                useradd $UNAME
                echo "$PASSWD" | passwd --stdin $UNAME &> /dev/null
                echo "$UNAME , Create success"
        fi
done
~~~



~~~text
/dev/null是一个被称作Linux黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。
~~~

**在Linux系统中，/etc/passwd是用来保存用户账户信息的文件。**

###### while条件循环语句

让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，完全不同于for循环语句中有目标、有范围的使用场景。while循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/while%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png)

编写一个用来猜测数值大小的脚本Guess.sh。该脚本使用$RANDOM变量来调取出一个随机的数值（范围为0～32767），然后将这个随机数对1000进行取余操作，并使用expr命令取得其结果，再用这个数值与用户通过read命令输入的数值进行比较判断。这个判断语句分为3种情况，分别是判断用户输入的数值是等于、大于还是小于使用expr命令取得的数值。当前，现在这些内容不是重点，我们要关注的是while条件循环语句中的条件测试始终为true，因此判断语句会无限执行下去，直到用户输入的数值等于expr命令取得的数值后，才运行exit 0命令，终止脚本的执行。

~~~
[root@linuxprobe ~]# vim Guess.sh
#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0
echo "商品实际价格为0-999之间，猜猜看是多少？"
while true
do
        read -p "请输入您猜测的价格数目：" INT
        let TIMES++
        if [ $INT -eq $PRICE ] ; then
                echo "恭喜您答对了，实际价格是 $PRICE"
                echo "您总共猜测了 $TIMES 次"
                exit
        elif [ $INT -gt $PRICE ] ; then
                echo "太高了！"
        else
                echo "太低了！"
        fi
done
~~~

###### case条件测试

case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/case%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84.png)

###### **计划任务服务程序**

计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解。

> **一次性计划任务**：今晚23:30重启网站服务。
>
> **长期性计划任务**：每周一的凌晨3:25把/home/wwwroot目录打包备份为backup.tar.gz。

**一次性计划任务**

一次性计划任务只执行一次，一般用于临时的工作需求。可以用at命令实现这种功能，只需要写成“at时间”的形式就行。如果想要查看已设置好但还未执行的一次性计划任务，可以使用at -l命令；要想将其删除，可以使用“atrm任务序号”。at命令中的参数及其作用如表4-6所示。

表4-6                        at命令的参数及其作用

| 参数 | 作用                   |
| ---- | ---------------------- |
| -f   | 指定包含命令的任务文件 |
| -q   | 指定新任务名称         |
| -l   | 显示待执行任务列表     |
| -d   | 删除指定待执行任务     |
| -m   | 任务执行后给用户发邮件 |

在使用at命令来设置一次性计划任务时，默认采用的是交互式方法。

将系统设置为在今晚23:30自动重启网站服务。

```
[root@linuxprobe ~]# at 23:30
warning: commands will be executed using /bin/sh
at> systemctl restart httpd
at> 此处请同时按下<Ctrl>+<d>键来结束编写计划任务
job 1 at Wed Oct 14 23:30:00 2020
[root@linuxprobe ~]# at -l
1 Wed Oct 14 23:30:00 2020 a root
```

管道符（任意门）放到两条命令之间，让at命令接收前面echo命令的输出信息，以达到通过非交互式的方式创建计划一次性任务的目的。

```
[root@linuxprobe ~]# echo "systemctl restart httpd" | at 23:30
warning: commands will be executed using /bin/sh
job 2 at Wed Oct 14 23:30:00 2020
[root@linuxprobe ~]# at -l
1 Wed Oct 14 23:30:00 2020 a root
2 Wed Oct 14 23:30:00 2020 a root
```

atrm命令删除指令

**特殊场景**

把计划任务写入Shell脚本中，当用户激活该脚本后再开始倒计时执行

使用“at now +2 MINUTE”的方式进行操作，这表示2分钟（MINUTE）后执行这个任务，也可以将其替代成小时（HOUR）、日（DAY）、月（MONTH）等词汇：

```
[root@linuxprobe ~]# at now +2 MINUTE
warning: commands will be executed using /bin/sh
at> systemctl restart httpd
at> 此处请同时按下<Ctrl>+<d>键来结束编写计划任务
job 3 at Wed Oct 14 22:50:00 2020
```

**周期性计划任务**

Linux系统中默认启用的crond服务。创建、编辑计划任务的命令为crontab -e，查看当前计划任务的命令为crontab -l，删除某条计划任务的命令为crontab -r。另外，如果您是以管理员的身份登录的系统，还可以在crontab命令中加上-u参数来编辑他人的计划任务。

表4-7                        crontab命令的参数及其作用

| 参数 | 作用         |
| ---- | ------------ |
| -e   | 编辑计划任务 |
| -u   | 指定用户名称 |
| -l   | 列出任务列表 |
| -r   | 删除计划任务 |

“分、时、日、月、星期 命令”。这是使用crond服务设置任务的参数格式，需要注意的是，如果有些字段没有被设置，则需要使用星号（*****）占位。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/02/cron%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8F%82%E6%95%B0.png)

| 字段 | 说明                                     |
| ---- | ---------------------------------------- |
| 分钟 | 取值为0～59的整数                        |
| 小时 | 取值为0～23的任意整数                    |
| 日期 | 取值为1～31的任意整数                    |
| 月份 | 取值为1～12的任意整数                    |
| 星期 | 取值为0～7的任意整数，其中0与7均为星期日 |
| 命令 | 要执行的命令或程序脚本                   |

假设在每周一、三、五的凌晨3:25，都需要使用tar命令把某个网站的数据目录进行打包处理，使其作为一个备份文件。我们可以使用crontab -e命令来创建计划任务，为自己创建计划任务时无须使用-u参数。crontab –e命令的具体实现效果和crontab -l命令的结果如下所示：

```
[root@linuxprobe ~]# crontab -e
no crontab for root - using an empty one
crontab: installing new crontab
[root@linuxprobe ~]# crontab -l
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot
```

除了用逗号（,）来分别表示多个时间段，例如“8,9,12”表示8月、9月和12月。还可以用减号（-）来表示一段连续的时间周期（例如字段“日”的取值为“12-15”，则表示每月的12～15日）。还可以用除号（/）表示执行任务的间隔时间（例如“*/2”表示每隔2分钟执行一次任务）。

**如果在crond服务中需要同时包含多条计划任务的命令语句，应每行仅写一条**

在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询。

~~~
在crond服务的配置参数中，一般会像Shell脚本那样以#号开头写上注释信息，这样在日后回顾这段命令代码时可以快速了解其功能、需求以及编写人员等重要信息。

计划任务中的“分”字段必须有数值，绝对不能为空或是*号，而“日”和“星期”字段不能同时使用，否则就会发生冲突。
~~~

删除crond计划任务则非常简单，直接使用crontab -e命令进入编辑界面，删除里面的文本信息即可。也可以使用crontab -r命令直接进行删除

### 用户身份与能力

Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。

~~~
管理员UID为0：系统的管理员用户。

系统用户UID为1～999：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。

普通用户UID从1000开始：是由管理员创建的用于日常工作的用户。
~~~

为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。

在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。

~~~
基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。
~~~

##### id命令

显示用户的详细信息，语法格式为“id 用户名”。

查看用户的基本信息，例如用户ID、基本组与扩展组GID，以便于我们判别某个用户是否已经存在，以及查看相关信息。

##### useradd命令

创建新的用户账户，语法格式为“useradd [参数] 用户名”。

该命令创建用户账户时，默认的用户家目录会被存放在/home目录中，默认的[Shell](https://www.linuxcool.com/)解释器为/bin/bash，而且默认会创建一个与该用户同名的基本用户组

表5-1                    useradd命令中的参数以及作用

| 参数 | 作用                                     |
| ---- | ---------------------------------------- |
| -d   | 指定用户的家目录（默认为/home/username） |
| -e   | 账户的到期时间，格式为YYYY-MM-DD.        |
| -u   | 指定该用户的默认UID                      |
| -g   | 指定一个初始的用户基本组（必须已存在）   |
| -G   | 指定一个或多个扩展用户组                 |
| -N   | 不创建与用户同名的基本用户组             |
| -s   | 指定该用户的默认Shell解释器              |

##### groupadd命令

创建新的用户组，语法格式为“groupadd [参数] 群组名”。

##### usermod命令

修改用户的属性，英文全称为“user modify”，语法格式为“usermod [参数] 用户名”。

Linux系统中的一切都是文件，因此在系统中创建用户也就是修改配置文件的过程。用户的信息保存在/etc/passwd文件中，可以直接用文本编辑器来修改其中的用户参数项目，也可以用usermod命令修改已经创建的用户信息，比如用户的UID、基本/扩展用户组、默认终端等。usermod命令的参数以及作用如表5-2所示。

表5-2                      usermod命令中的参数以及作用

| 参数  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| -c    | 填写用户账户的备注信息                                       |
| -d -m | 参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去 |
| -e    | 账户的到期时间，格式为YYYY-MM-DD                             |
| -g    | 变更所属用户组                                               |
| -G    | 变更扩展用户组                                               |
| -L    | 锁定用户禁止其登录系统                                       |
| -U    | 解锁用户，允许其登录系统                                     |
| -s    | 变更默认终端                                                 |
| -u    | 修改用户的UID                                                |

##### passwd命令

修改用户的密码、过期时间等信息，英文全称为“password”，语法格式为“passwd [参数] 用户名”。

普通用户只能使用passwd命令修改自己的系统密码，而root管理员则有权限修改其他所有人的密码。

   passwd命令中的参数以及作用

| 参数    | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| -l      | 锁定用户，禁止其登录                                         |
| -u      | 解除锁定，允许用户登录                                       |
| --stdin | 允许通过标准输入修改用户密码，如echo "NewPassWord" \| passwd --stdin Username |
| -d      | 使该用户可用空密码登录系统                                   |
| -e      | 强制用户在下次登录时修改密码                                 |
| -S      | 显示用户的密码是否被锁定，以及密码所采用的加密算法名称       |

##### userdel命令

删除已有的用户账户，英文全称为“user delete”，语法格式为“userdel [参数] 用户名”。

表5-4                       userdel命令中的参数以及作用

| 参数 | 作用                     |
| ---- | ------------------------ |
| -f   | 强制删除用户             |
| -r   | 同时删除用户及用户家目录 |

在删除一个用户时，一般会建议保留他的家目录数据，以免有重要的数据被误删除。所以在使用userdel命令时可以不加参数，写清要删除的用户名称就行

### 文件权限与归属

“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个[脚本](https://www.linuxcool.com/)程序。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。

  读写执行权限对于文件与目录可执行命令的区别

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E8%AF%BB%E5%86%99%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E5%AF%B9%E4%BA%8E%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8-1024x168.png)

文件的可读、可写、可执行权限的英文全称分别是read、write、execute，可以简写为r、w、x，亦可分别用数字4、2、1来表示，文件所有者、文件所属组及其他用户权限之间无关联，如表5-6所示。

表5-6                       文件权限的字符与数字表示

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%8E%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA-1024x201.png)

以rw-r-x-w-权限为例来介绍如何将字符表示的权限转换为数字表示的权限

![image-20220722110440523](C:\Users\Xlibi\AppData\Roaming\Typora\typora-user-images\image-20220722110440523.png)

![image-20220722110329093](C:\Users\Xlibi\AppData\Roaming\Typora\typora-user-images\image-20220722110329093.png)

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E6%9D%83%E9%99%90%E8%BD%AC%E6%8D%A2-300x136.jpg)

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2015/02/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png)

包含了文件的类型、访问权限、所有者（属主）、所属组（属组）、占用的磁盘大小、最后修改时间和文件名称等信息。通过分析可知，该文件的类型为普通文件，所有者权限为可读、可写（rw-），所属组权限为可读（r--），除此以外的其他人也只有可读权限（r--），文件的磁盘占用大小是34298字节，最近一次的修改时间为4月2日的0:23，文件的名称为install.log。

常见的文件类型包括普通文件（-）、目录文件（d）、链接文件（l）、管道文件（p）、块设备文件（b）以及字符设备文件（c）。

![image-20220722111457809](C:\Users\Xlibi\AppData\Roaming\Typora\typora-user-images\image-20220722111457809.png)

### 文件的特殊权限

单纯设置文件的rwx权限无法满足我们对安全和灵活性的需求，因此便有了SUID、SGID与SBIT的特殊权限位。这是一种对文件权限进行设置的特殊功能，可以与一般权限同时使用，以弥补一般权限不能实现的功能。

##### SUID

SUID是一种对二进制程序进行设置的特殊权限，能够让二进制程序的执行者临时拥有所有者的权限（仅对拥有执行权限的二进制程序有效）。

##### SGID

当对二进制程序进行设置时，能够让执行者临时获取文件所属组的权限；当对目录进行设置时，则是让目录内新创建的文件自动继承该目录原有用户组的名称。

chmod命令用于设置文件的一般权限及特殊权限，英文全称为“change mode”，语法格式为“chmod [参数] 文件名”。

这是一个与文件权限的日常设置强相关的命令。例如，要把一个文件的权限设置成其所有者可读可写可执行、所属组可读可写、其他人没有任何权限，则相应的字符法表示为rwxrw----，其对应的数字法表示为760。

chown命令用于设置文件的所有者和所有组，英文全称为change own，语法格式为“chown所有者:所有组 文件名”。

chmod和chown命令是用于修改文件属性和权限的最常用命令，它们还有一个特别的共性，就是针对目录进行操作时需要加上大写参数-R来表示递归操作，即对目录内所有的文件进行整体操作。

##### SBIT

SBIT特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。换句话说，当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者执行删除操作了。

表5-7                     SUID、SGID、SBIT特殊权限的设置参数

| 参数 | 作用         |
| ---- | ------------ |
| u+s  | 设置SUID权限 |
| u-s  | 取消SUID权限 |
| g+s  | 设置SGID权限 |
| g-s  | 取消SGID权限 |
| o+t  | 设置SBIT权限 |
| o-t  | 取消SBIT权限 |

SUID、SGID与SBIT也有对应的数字表示法，分别为4、2、1


![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90%E6%95%B0%E5%AD%97%E6%B3%95%E8%AE%A1%E7%AE%97-300x244.jpg)

图5-4 权限的字符表示法转数字表示法

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90%E5%AD%97%E7%AC%A6%E6%B3%95%E8%AE%A1%E7%AE%97-1-300x223.jpg)

图5-5 权限的数字表示法转字符标识法

### 文件的隐藏属性

#### chattr命令

设置文件的隐藏权限，英文全称为change attributes，语法格式为“chattr [参数] 文件名称”。

  chattr命令中的参数及其作用。如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”

| 参数 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| i    | 无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件 |
| a    | 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）     |
| S    | 文件内容在变更后立即同步到硬盘（sync）                       |
| s    | 彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）      |
| A    | 不再修改这个文件或目录的最后访问时间（atime）                |
| b    | 不再修改文件或目录的存取时间                                 |
| D    | 检查压缩文件中的错误                                         |
| d    | 使用dump命令备份时忽略本文件/目录                            |
| c    | 默认将文件或目录进行压缩                                     |
| u    | 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复         |
| t    | 让文件系统支持尾部合并（tail-merging）                       |
| x    | 可以直接访问压缩文件中的内容                                 |

#### lsattr命令

查看文件的隐藏权限，英文全称为“list attributes”，语法格式为“lsattr [参数] 文件名称”。

### 文件访问控制列表

如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。通俗来讲，基于普通文件或目录设置ACL其实就是针对指定的用户或用户组设置文件或目录的操作权限，更加精准地派发权限。另外，如果针对某个目录设置了ACL，则目录中的文件会继承其ACL权限；若针对文件设置了ACL，则文件不再继承其所在目录的ACL权限。

#### setfacl命令

管理文件的ACL权限规则，英文全称为“set files ACL”，语法格式为“setfacl [参数] 文件名称”。

ACL权限提供的是在所有者、所属组、其他人的读/写/执行权限之外的特殊权限控制。使用setfacl命令可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。其中，针对目录文件需要使用-R递归参数；针对普通文件则使用-m参数；如果想要删除某个文件的ACL，则可以使用-b参数。setfacl命令的常用参数如表5-9所示。

表5-9                       setfacl命令中的参数以及作用

| 参数 | 作用             |
| ---- | ---------------- |
| -m   | 修改权限         |
| -M   | 从文件中读取权限 |
| -x   | 删除某个权限     |
| -b   | 删除全部权限     |
| -R   | 递归子目录       |

#### getfacl命令

查看文件的ACL权限规则，英文全称为“get files ACL”，语法格式为“getfacl [参数] 文件名称”。

允许某个组的用户都可以读写/etc/fstab文件：

```
setfacl -m g:linuxprobe:rw /etc/fstab
```

要清空所有ACL权限，请用-b参数；要删除某一条指定的权限，就用-x参数：ACL权限的恢复也很简单，使用的是--restore参数。

#### su命令与sudo命令

的su命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。

当从root管理员切换到普通用户时是不需要密码验证的，而从普通用户切换成root管理员就需要进行密码验证了

sudo命令用于给普通用户提供额外的权限，语法格式为“sudo [参数] 用户名”。

表5-10                     sudo命令中的可用参数以及作用

| 参数             | 作用                                                   |
| ---------------- | ------------------------------------------------------ |
| -h               | 列出帮助信息                                           |
| -l               | 列出当前用户可执行的命令                               |
| -u 用户名或UID值 | 以指定的用户身份执行命令                               |
| -k               | 清空密码的有效时间，下次执行sudo时需要再次进行密码验证 |
| -b               | 在后台执行指定的命令                                   |
| -p               | 更改询问密码的提示语                                   |

如果担心直接修改配置文件会出现问题，则可以使用sudo命令提供的visudo命令来配置用户权限。

visudo命令用于编辑、配置用户sudo的权限文件，语法格式为“visudo [参数]”。

这是一条会自动调用vi编辑器来配置/etc/sudoers权限文件的命令，能够解决多个用户同时修改权限而导致的冲突问题。不仅如此，visudo命令还可以对配置文件内的参数进行语法检查，并在发现参数错误时进行报错提醒。这要比用户直接修改文件更友好、安全、方便。

。在配置权限文件时，按照下面的格式在第101行（大约）填写上指定的信息。

> **谁可以使用 允许使用的主机 = （以谁的身份） 可执行命令的列表**
>
> **谁可以使用：**稍后要为哪位用户进行命令授权。
>
> **允许使用的主机：**可以填写ALL表示不限制来源的主机，亦可填写如192.168.10.0/24这样的网段限制来源地址，使得只有从允许网段登录时才能使用sudo命令。
>
> **以谁的身份：**可以填写ALL表示系统最高权限，也可以是另外一位用户的名字。
>
> **可执行命令的列表：**可以填写ALL表示不限制命令，亦可填写如/usr/bin/cat这样的文件名称来限制命令列表，多个命令文件之间用逗号（,）间隔。



### 存储结构

Linux系统中的文件和目录名称是严格区分大小写的。例如，root、rOOt、Root、rooT均代表不同的目录，并且文件名称中不得包含斜杠（/）

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2015/02/Linux%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84.png)

表6-1                 Linux系统中常见的目录名称以及相应内容

| 目录名称    | 应放置文件的内容                                             |
| ----------- | ------------------------------------------------------------ |
| /boot       | 开机所需文件—内核、开机菜单以及所需配置文件等                |
| /dev        | 以文件形式存放任何设备与接口                                 |
| /etc        | 配置文件                                                     |
| /home       | 用户主目录                                                   |
| /bin        | 存放单用户模式下还可以操作的[命令](https://www.linuxcool.com/) |
| /lib        | 开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数    |
| /sbin       | 开机过程中需要的命令                                         |
| /media      | 用于挂载设备文件的目录                                       |
| /opt        | 放置第三方的软件                                             |
| /root       | 系统管理员的家目录                                           |
| /srv        | 一些网络服务的数据文件目录                                   |
| /tmp        | 任何人均可使用的“共享”临时目录                               |
| /proc       | 虚拟文件系统，例如系统内核、进程、外部设备及网络状态等       |
| /usr/local  | 用户自行安装的软件                                           |
| /usr/sbin   | Linux系统开机时不会使用到的软件/命令/[脚本](https://www.linuxcool.com/) |
| /usr/share  | 帮助与说明文件，也可放置共享文件                             |
| /var        | 主要存放经常变化的文件，如日志                               |
| /lost+found | 当文件系统发生错误时，将一些丢失的文件片段存放在这里         |

**绝对路径相对路径**

~~~
绝对路径（absolute path）：首先坐飞机来到中国，到了北京后出首都机场，坐机场快轨到三元桥，然后换乘10号线到潘家园站，出站后坐34路公交车到农光里，下车后路口左转。

相对路径（relative path）：前面路口左转。
~~~

#### 物理设备命名规则

udev设备管理器的服务会一直以守护进程的形式运行并侦听内核发出的信号来管理/dev目录下的设备文件。

Linux系统中常见的硬件设备及其文件名称如表6-2所示。

表6-2                       常见的硬件设备及其文件名称

| 硬件设备      | 文件名称           |
| ------------- | ------------------ |
| IDE设备       | /dev/hd[a-d]       |
| SCSI/SATA/U盘 | /dev/sd[a-z]       |
| virtio设备    | /dev/vd[a-z]       |
| 软驱          | /dev/fd[0-1]       |
| 打印机        | /dev/lp[0-15]      |
| 光驱          | /dev/cdrom         |
| 鼠标          | /dev/mouse         |
| 磁带机        | /dev/st0或/dev/ht0 |

由于现在的IDE设备已经很少见了，所以一般的硬盘设备都是以“/dev/sd”开头。而一台主机上可以有多块硬盘，因此系统采用a～z来代表26块不同的硬盘（默认从a开始分配），而且硬盘的分区编号也很有讲究：

> 主分区或扩展分区的编号从1开始，到4结束；
>
> 逻辑分区从编号5开始。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2015/02/%E7%A1%AC%E7%9B%98%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99.png)

硬盘设备是由大量的扇区组成的，每个扇区的容量为512字节。其中第一个扇区最重要，它里面保存着主引导记录与分区表信息。就第一个扇区来讲，主引导记录需要占用446字节，分区表占用64字节，结束符占用2字节；其中分区表中每记录一个分区信息就需要16字节，这样一来最多只有4个分区信息可以写到第一个扇区中，这4个分区就是4个主分区。第一个扇区中的数据信息如图6-3所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%89%87%E5%8C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF-1.jpg)

#### 文件系统与数据资料
